## 自我介绍

## 技术

### JAVA核心

1.说一下你对面向对象编程的理解。

> 分两个方面来说
>
> 第一、面向对象编程的步骤：设计类，创建对象，调用方法
>
> 第二、面向对象编程的特征：封装，继承 和 多态 。封装即私有化成员属性，定义setter,getter;继承即由一个类派生出新的类；多态即对象在运行过程中有多种状态，必要条件：a.要有继承关系, b.子类重写父类方法 c.父类引用指向子类对象。
>
> 第三、面向对象编程核心思想：抽象 。提取可公用的。代码的演化就是不断抽象的过程，从多个对象，抽象成一个父类，从多个代码段，抽象出公用方法。从多套流程中抽象出公用的框架。从多个平台抽象出可公用的服务，做成分布式系统，甚至 中台服务。

2.说下你常用的设计模式。

[(7条消息) Java常用的设计模式_qixiang_chen的博客-CSDN博客_java常用的设计模式](https://blog.csdn.net/qixiang_chen/article/details/88381325)

[(7条消息) Java程序员必备，史上最详细常用的八种设计模式讲解丨建议收藏_Java进阶之路的博客-CSDN博客](https://blog.csdn.net/weixin_45039616/article/details/103096625)

> 1.单例模式：懒汉，恶汉，Double Check Lock （DCL）单例
>
> 2.工厂模式
>
> 3.装饰者
>
> 4.代理
>
> 5.适配器
>
> 6.模板方法模式
>
> 7.策略模式

3.讲一下java内存模型（Java Memory Model）

> 这是一种规范
>
> [Java内存模型（JMM）总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/29881777)

4.讲一下jvm内存模型

> 1.线程私有的模型：虚拟机栈（局部变量表，操作数栈，指向常量池的指针），程序计数器，本地方法栈
>
> 2.线程公有的模型：方法区（存字节码文件即类文件）、堆（存对象实例）
>
> 3.java执行引擎：执行解释器，对字节码进行优化，执行GC清理垃圾
>
> 4.类加载器：

5.说一下从编码，到类加载过程

> 1.先说一个整体的过程： 从编码到执行，java文件被javac编译成class文件，通过ClassLoader加载完成，将字节码文件交给执行引擎，然后通过解释器和即时编译器的分析和优化后 进行执行。
>
> 2.然后说道ClassLoader的类加载过程：大体分为3个步骤 Loading - Linking - Initializing
>
>  加载 - 验证 - 准备 - 解析 - 初始化 - 使用 - 卸载
>
> 加载 -- 将.class文件中的二进制字节流读入到JVM
>
> 验证 -- 确保加载进来的字节流符合JVM规范
>
> 准备 -- 为静态变量在方法区分配内存 ， 并设置默认初始值
>
> 解析 -- 将类、方法、属性 等**符号引用**解析为**直接引用**
>
> **初始化**-- 根据程序中的赋值语句 为变量赋值

6.说一下类的初始化

> 什么时候会进行初始化？
>
> 1. new
> 2. 调用类静态字段,方法（final static 字段变量，编译期就被放入常量池）
> 3. 调用反射
>
> 初始化顺序？
>
> 1. 父类静态块和静态变量赋值（按声明顺序）
> 2. 自身静态块和静态变量赋值（安声明顺序）
> 3. 父类成员变量
> 4. 父类构造器（使用super("参数") 可以指定调用父类构造器）
> 5. 自身成员变量
> 6. 自身构造器
>
> 类加载机制？
>
> 1. 全盘负责：当一个类被某类加载器加载后，该类的依赖也都有此类加载器负责加载，除非显示使用另一个类加载器
> 2. 双亲委派：先让父类加载器加载，层层递推，根加载器还是不行，那就再下来，让子加载器加载
> 3. 缓存机制：被加载过的类，存在缓存中，下次调用直接取缓存
>
> 类加载器？
>
> 1. 根类加载器 （BootStrap）：加载一些核心类，rt.jar charset.jar 等核心类和C++实现
> 2. 扩展类加载器 （Extension）：加载扩展jar ，jre/lib/ext包下的 jar 或可由参数指定
> 3. 系统类加载器 （App）：加载classpath指定内容
> 4. 用户类加载器 （Custom）：自定义
>
> 为何双亲委派？
>
>  唯一性，保证加载过的不再加载，安全性，保证某些核心api不会被篡改

7.堆内存空间如何划分，如何回收这些内存对象，有哪些回收算法？

> 1.分为 ：新生代和老年代。 为何这么分：不同的分代存不同类型的对象，方便使用不同的算法分别治理；有些对象生的快死得快，有的对象一直活着；
>
>  新生代留下的对象少，因此可以用复制算法 进行 整理，释放内存空间
>
>  复制到哪里去？因此要给新生代分区，Eden区和Survivor Space (又分From 区To区)
>
>  老年代对象多，使用标记清除算法，大量垃圾对象直接干掉
>
> 2.有哪些回收算法：标记清除，复制、标记整理
>
> 3.为什么再jdk1.8干掉MetaSpace ？

8.常用GC算法

> 1.引用计数法 2.标记清除 3.标记-压缩 4.复制

9.常用垃圾回收器

> 1.serial 收集器 采用xxx算法 串行收集，但会有STW
>
> 2.serial old 是 serial的 老年代版本：采用 标记-整理算法 单线程
>
> 3.parallel scavenge (并行拾荒) ：采用复制算法的并行收集器 也有STW
>
> 4.parallel old 是ps的老年代版本 ：采用 标记-整理 算法的并行收集器
>
> 5.ParNew serial的多线程版本 ：一样存在STW
>
> 6.CMS （concurrent mark sweep）：已最短停顿时间为目标的收集器，基于标记-清除算法，并发收集。运行步骤：初始标记，并发标记，重新标记，并发清除

 垃圾回收器如何选择

> ParNew和ParallelOld不能一起用
>
> 单线程收集器不行，用多线程，但还是有STW，所以出现了CMS，随着当下内存越来越大，导致CMS时碎片太多，因此引用G1
>
> G1（整堆收集器）直接处理新生代和老年代

10.如何解决线上频繁GC的问题

> 1.根据监控，确定问题发生的时间点，根据时间定位，查看版本，是谁提交了什么代码
>
> 2.根据jmap 定位jvm参数
>
> 需补充

11.内存溢出的原因，如何排查

> 引出：什么是内存溢出、什么是内存泄漏？ 溢出是内存超过虚拟机限制，泄漏是内存空间中有一部分没有被利用起来，永远不会被用起来。
>
> 需要在参数中设定，在出现内存溢出的时候，dump出内存快照，便于追踪

12.happen - before 规则？

13.内存屏障的汇编指令

14.有哪些jvm调优实战经验？

### java并发编程相关

并发这里有两部分

1.说一说线程创建的几种方法

> 1. 继承Thread重写run
> 2. 实现Runable接口
> 3. 实现Callable接口
> 4. 使用FutureTask包装Callable，一个可中断，可阻塞等待取回结果的线程工具
>
> 但本质上只有一种方法，即通过Tread对象调其start方法，因为不管是Runable还是线程池，底层的源码都是这种模式。

2.线程执行原理和顺序

> 1. jvm内存结构 : 线程私有（虚拟机栈，本地方法栈，PC寄存器），共有（堆，方法区）
> 2. 每一个线程启动时都会有一个栈，每调用一个方法创建一个活动栈帧，栈帧中包含（局部变量表，返回地址，锁记录，操作数栈）
> 3. 程序计数器去方法区获取指令
> 4. 获取到main方法，创建main栈帧，参数读入局部变量表，并记录返回地址
> 5. 获取下一条指令

3.如何判断是否线程安全和线程不安全

> 看是否共享，是否有写操作；例如静态变量一般都是共享的，但如果这个变量只读，那线程安全。但如果有写操作，那线程不安全

3.工作线程数，或线程池中线程数 设置多少合适？ 
$$
N = Ncpu(核数) * Ucpu(期望cpu利用率) * (1+W(线程等待时间)/C(线程执行时间))
$$
​	 其中W/C怎么计算? 使用软件测算 Profiler测试；但如果实际环境和压测不一样呢？可以用Arthas监控。

4.Synchronize的底层实现

![](..\图片\image-20210511154542728.png)

> 首先要知道，对象头：32位虚拟机，对象头markword有64位（8字节）,4个字节是MarkWord，另外4个字节是 KlassWord
>
> MarkWord(4字节，32位)：25位 HashCode，4位 分代年龄，2位 是否偏向 ，2位 锁状态。
>
> Monitor（锁）：Monitor被翻译为 **监视器** 或者 **管程** ，每个java对象都可以关联一个Monitor对象，此对象中有三个区域 Owner，EntrySet，WaitSet。
>
> 刚开始Monitor中的Owner位null 当线程执行到Sychronized代码块时，就会将Onwer置位占有线程，MarkWord中的hashCode被替换为对应的Monitor对象地址
>
> 在上锁状态时，其他线程来访问锁，会进入EntrySet，直到站有锁线程执行完，EntrySet中线程竞争获取Owner位置。
>
> Wait/Notify的原理：当线程获得锁，但又不满足某些条件时，调用wait方法使其进入waitSet进行等待，直到被Owner线程唤醒notify/notifyAll，再从waitSet进入EntryList一起等待竞争锁。

5.锁升级的过程

> 1. 轻量级锁：一个资源多线程访问，但访问时间是错开的，那么使用轻量级锁；
>
> 2. 创建锁记录：每个线程的栈帧都会包含一个锁记录，当一个对象要上锁时，去栈帧中存储自己的对象引用，并将锁记录中存储的 锁记录地址 信息和MarkWord中的对象hashcode等交换，即CAS
>
> 3. 如果上锁失败：即MarkWord中的锁状态不是01, 那进入 **锁膨胀** 或者 **锁重入**。
>
> 4. 锁膨胀：当某对象的MarkWord中的地址已被Thread1替换为00即轻量级锁，此时另一个线程2来请求共享资源，访问这把锁，请求失败；则为当前锁对象申请一个Monitor对象，并将对象中的MarkWord改为重量级锁的地址，然后Thread2进入Monitor的EntryList，上锁完成。当Thread1要解锁时，先尝试直接交换锁记录和MarkWord但发现无法交换，因为此时不是轻量级锁，锁状态为不是01，所以走重量级锁的解锁流程
>
> 5. 自旋优化：当T1已经上了重量级锁的时候，T2来竞争锁，会先进行几次自旋等待，自旋等待成功直接上锁，失败则进入EntryList(多核Cpu自旋才有意义)
>
> 6. 偏向锁：java6引入对锁进一步优化，多次锁重入时，每次进行CAS有点浪费性能。因此进入偏向锁，直接将MarkWord中写上当前线程Id。默认启用偏向锁的
>
> 7. 偏向锁撤销
>
>    几个参数：
>
> ```java
> //关闭延迟开启偏向锁
> -XX:BiasedLockingStartupDelay=0
> //禁止偏向锁
> -XX:-UseBiasedLocking 
> //启用偏向锁
> -XX:+UseBiasedLocking 
> ```
>
> ​		当一个可偏向的对象上锁前，调用一下对象的hashCode方法，会禁用偏向锁，因为偏向对象的MarkWord没		地方存储HashCode.
>
> ​		当有竞争的时候，且没有交错竞争，撤销偏向，**升级为轻量级锁**
>
> ​		当调用wait/Notify的时候，撤销偏向，**升级为重量级锁**
>
>  8. 批量重偏向  多个锁已被设置偏向状态后，再被另一个线程调用，偏向另一个线程超过20，剩下的所有都批量改为偏向另一个线程。
>
>  9. 批量撤销 超过39次
>
>  10. 锁消除
>
>      因为即时编译器的存在，代码中的热点代码可能会被进行锁消除的优化，synchronized代码可能被优化掉。可通过参数设定 java -XX:-EliminateLocks
>
>      
>
>      

6.Synchronized的可重入特性

> 一个类中的两个方法都加锁了，使用同一把锁即锁定同一个对象，一个线程，调用，方法1，方法1中又调用了方法2，当前被锁定对象发现是同一个线程，那么允许再次上锁。

7.wait(n)和sleep(n)的区别

> 1. sleep是Thread的静态方法，wait是Object的方法
> 2. wait需要配合Synchronize一起用
> 3. Sleep等待是不会释放锁的，wait会释放

8.Join的原理

> 1. （同步模式）保护性暂停模式：使用一个对象进行中间的协调者，在其中可有容器对象，get方法，set方法，利用wait和notify组合使用

9.生产者消费者模式（异步模式）

> 与保护暂停模式不同的是：不需要产生结果和消费结果的线程一一对应
>
> 队列有容量限制，可以平衡生产和消费

10.Wait/Notify和Park/UnPark的区别

> 1. wait/notify需要配合Monitor才能枷锁
> 2. notify只能随机唤醒某个等待区的线程，notifyAll能唤醒所有，不精确，unPark能指定唤醒某线程
> 3. unPark能先于Park执行，也能唤醒线程

11.park/unPark原理

![image-20210512175225489](..\图片\image-20210512175225489.png)

> ​		每一个线程包含一个Parker对象，其中包含_mutex对象，和_counter计数器，mutex对象中包含_cond数组

12.线程的活跃性

> 1. 死锁：两个线程互相持有对方的锁，死锁
> 2. 定位死锁： jstack, jconsole 查看block状态的线程
> 3. 哲学家就餐问题：五个人，5只筷子，最后，一人拿着一只筷子等待别人放下筷子，导致死锁
> 4. 活锁：两个线程改变了对方的结束条件，谁也停不下来
> 5. 饥饿：有一种解释是某些线程由于优先级低而长时间无法获得锁；还有一种出现饥饿的情况是，当为了解决死锁问题而使用顺序加锁方案的时候，很有可能出现饥饿，就比如哲学家就餐时，拿筷子都按顺序拿。

13.ReentrantLock和Synchronize比的优势

> 1. 支持公平锁
> 2. 可以有多个条件变量，多个WaitSet，精准唤醒，防止虚假唤醒
>    1. 虚假唤醒：notifyAll 使用时不能精确唤醒，会唤醒WaitSet中的所有线程，所以有的线程并不满足条件也被唤醒的，叫虚假唤醒。
> 3. 可打断

14.同步模式--交替输出

> 1. 使用wait/notify
>    1. 关键在于设置一个int类型标记位，用while判断当前执行线程是否和标记一致，如果一致才放行，执行完后将标记位改为下一顺序位的线程，再notifyAll叫醒所有等待线程。
> 2. 使用ReentrantLock

14.可重入锁和不可重入锁都有哪些

5.Volatile的作用

6.CAS是什么

7.ReentrantLock底层实现

8.JUC包的其他同步锁工具有哪些了解

9.说一下并发容器类

​	ConcureentHshMap

​	 2.HashMap为什么使用红黑树？

> 连续元素超过8将后面的数据存在红黑树中 ，便于检索

10.常用线程池和自定义线程池的使用和原理

11.如何预防死锁

> 什么是死锁？资源有限，

### Spring相关

### 分布式相关

### 运维与Linux相关