## 自我介绍

## 技术

### JAVA核心

1.说一下你对面向对象编程的理解。

> 分两个方面来说
>
> 第一、面向对象编程的步骤：设计类，创建对象，调用方法
>
> 第二、面向对象编程的特征：封装，继承 和 多态 。封装即私有化成员属性，定义setter,getter;继承即由一个类派生出新的类；多态即对象在运行过程中有多种状态，必要条件：a.要有继承关系, b.子类重写父类方法 c.父类引用指向子类对象。
>
> 第三、面向对象编程核心思想：抽象 。提取可公用的。代码的演化就是不断抽象的过程，从多个对象，抽象成一个父类，从多个代码段，抽象出公用方法。从多套流程中抽象出公用的框架。从多个平台抽象出可公用的服务，做成分布式系统，甚至 中台服务。

2.说下你常用的设计模式。

[(7条消息) Java常用的设计模式_qixiang_chen的博客-CSDN博客_java常用的设计模式](https://blog.csdn.net/qixiang_chen/article/details/88381325)

[(7条消息) Java程序员必备，史上最详细常用的八种设计模式讲解丨建议收藏_Java进阶之路的博客-CSDN博客](https://blog.csdn.net/weixin_45039616/article/details/103096625)

> 1.单例模式：懒汉，恶汉，Double Check Lock （DCL）单例
>
> 2.工厂模式
>
> 3.装饰者
>
> 4.代理
>
> 5.适配器
>
> 6.模板方法模式
>
> 7.策略模式

3.讲一下java内存模型（Java Memory Model）

> [Java内存模型（JMM）总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/29881777)

4.讲一下jvm内存模型

> 1.线程私有的模型：虚拟机栈（局部变量表，操作数栈，指向常量池的指针），程序计数器，本地方法栈
>
> 2.线程公有的模型：方法区（存字节码文件即类文件）、堆（存对象实例）
>
> 3.java执行引擎：执行解释器，对字节码进行优化，执行GC清理垃圾
>
> 4.类加载器：

<<<<<<< HEAD
<<<<<<< HEAD
5.说一下从编码，到类加载过程

> 1.先说一个整体的过程： 从编码到执行，java文件被javac编译成class文件，通过ClassLoader加载完成，将字节码文件交给执行引擎，然后通过解释器和即时编译器的分析和优化后 进行执行。
>
> 2.然后说道ClassLoader的类加载过程：大体分为3个步骤 Loading - Linking - Initializing 
>
> ​	加载 - 验证 - 准备 - 解析 - 初始化 - 使用 - 卸载	
>
> 加载 -- 将.class文件中的二进制字节流读入到JVM
>
> 验证 --  确保加载进来的字节流符合JVM规范
>
> 准备 --  为静态变量在方法区分配内存 ， 并设置默认初始值
>
> 解析 -- 将类、方法、属性 等**符号引用**解析为**直接引用**
>
> **初始化**-- 根据程序中的赋值语句 为变量赋值

6.说一下类的初始化

> 什么时候会进行初始化？
>
> 1. new
> 2. 调用类静态字段,方法（final static 字段变量，编译期就被放入常量池）
> 3. 调用反射
>
> 初始化顺序？
>
> 	1. 父类静态块和静态变量赋值（按声明顺序）
> 	2. 自身静态块和静态变量赋值（安声明顺序）
> 	3. 父类成员变量
> 	4. 父类构造器（使用super("参数") 可以指定调用父类构造器）
> 	5. 自身成员变量
> 	6. 自身构造器
>
> 类加载机制？
>
> 	1. 全盘负责：当一个类被某类加载器加载后，该类的依赖也都有此类加载器负责加载，除非显示使用另一个类加载器
> 	2. 双亲委派：先让父类加载器加载，层层递推，根加载器还是不行，那就再下来，让子加载器加载
> 	3. 缓存机制：被加载过的类，存在缓存中，下次调用直接取缓存
>
> 类加载器？
>
> 	1. 根类加载器 （BootStrap）：加载一些核心类，rt.jar  charset.jar 等核心类和C++实现
> 	2. 扩展类加载器 （Extension）：加载扩展jar ，jre/lib/ext包下的 jar  或可由参数指定
> 	3. 系统类加载器 （App）：加载classpath指定内容
> 	4. 用户类加载器 （Custom）：自定义
>
> 为何双亲委派？
>
> ​	唯一性，保证加载过的不再加载，安全性，保证某些核心api不会被篡改

6.堆内存空间如何划分，如何回收这些内存对象，有哪些回收算法？
=======
5.堆内存空间如何划分，如何回收这些内存对象，有哪些回收算法？
>>>>>>> parent of 4c569fa (面试押题)
=======
5.堆内存空间如何划分，如何回收这些内存对象，有哪些回收算法？
>>>>>>> parent of 4c569fa (面试押题)

> 1.分为 ：新生代和老年代。 为何这么分：不同的分代存不同类型的对象，方便使用不同的算法分别治理；有些对象生的快死得快，有的对象一直活着；
>
> ​	新生代留下的对象少，因此可以用复制算法 进行 整理，释放内存空间
>
> ​		复制到哪里去？因此要给新生代分区，Eden区和Survivor Space (又分From 区To区)
>
> ​	老年代对象多，使用标记清除算法，大量垃圾对象直接干掉
>
> 2.有哪些回收算法：标记清除，复制、标记整理
>
> 3.为什么再jdk1.8干掉MetaSpace ？

6.常用GC算法

> 1.引用计数法  2.标记清除 3.标记-压缩  4.复制

7.常用垃圾回收器

> 1.serial 收集器 采用xxx算法  串行收集，但会有STW
>
> 2.serial old 是 serial的 老年代版本：采用 标记-整理算法 单线程
>
> 3.parallel scavenge (并行拾荒) ：采用复制算法的并行收集器 也有STW
>
> 4.parallel old 是ps的老年代版本 ：采用 标记-整理 算法的并行收集器
>
> 5.ParNew  serial的多线程版本 ：一样存在STW
>
> 6.CMS （concurrent mark sweep）：已最短停顿时间为目标的收集器，基于标记-清除算法，并发收集。运行步骤：初始标记，并发标记，重新标记，并发清除

​		垃圾回收器如何选择

> ParNew和ParallelOld不能一起用
>
> 单线程收集器不行，用多线程，但还是有STW，所以出现了CMS，随着当下内存越来越大，导致CMS时碎片太多，因此引用G1
>
> G1（整堆收集器）直接处理新生代和老年代
>
> 

8.如何解决线上频繁GC的问题

> 1.根据监控，确定问题发生的时间点，根据时间定位，查看版本，是谁提交了什么代码
>
> 2.根据jmap 定位jvm参数
>
> 需补充

9.描述一下Class初始化过程

10.内存溢出的原因，如何排查

> 引出：什么是内存溢出、什么是内存泄漏？ 溢出是内存超过虚拟机限制，泄漏是内存空间中有一部分没有被利用起来，永远不会被用起来。
>
> 需要在参数中设定，在出现内存溢出的时候，dump出内存快照，便于追踪

11.happen - before 规则？

12.内存屏障的汇编指令

13.有哪些jvm调优实战经验？

### java并发编程相关

<<<<<<< HEAD
<<<<<<< HEAD
并发这里有两部分  

1.说一说线程创建的几种方法

> 1. 继承Thread重写run
> 2. 实现Runable接口
> 3. 实现Callable接口
> 4. 使用FutureTask包装Callable，一个可中断，可阻塞等待取回结果的线程工具
>
> 但本质上只有一种方法，即通过Tread对象调其start方法，因为不管是Runable还是线程池，底层的源码都是这种模式。

2.线程执行原理



3.工作线程数，或线程池中线程数  设置多少合适？
$$
N = Ncpu(核数) * Ucpu(期望cpu利用率) * (1+W(线程等待时间)/C(线程执行时间))
$$
​	其中W/C怎么计算? 使用软件测算 Profiler测试；但如果实际环境和压测不一样呢？可以用Arthas监控。

4.Synchronize的底层实现

5.Volatile的作用

6.CAS是什么

7.ReentrantLock底层实现

8.JUC包的其他同步锁工具有哪些了解

9.说一下并发容器类
=======
=======
>>>>>>> parent of 4c569fa (面试押题)
1.说一说集合类，项目中是如何使用的？多聊集合类 甚至 JUC包下的并发容器
>>>>>>> parent of 4c569fa (面试押题)

 ConcureentHshMap

​	2.HashMap为什么使用红黑树？

> 连续元素超过8将后面的数据存在红黑树中 ，便于检索

10.常用线程池和自定义线程池的使用和原理









11.如何预防死锁

> 什么是死锁？资源有限，









### Spring相关

### 分布式相关

### 运维与Linux相关











