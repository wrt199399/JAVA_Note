## 自我介绍

## 技术

### JAVA核心

1.说一下你对面向对象编程的理解。

> 分两个方面来说
>
> 第一、面向对象编程的步骤：设计类，创建对象，调用方法
>
> 第二、面向对象编程的特征：封装，继承 和 多态 。封装即私有化成员属性，定义setter,getter;继承即由一个类派生出新的类；多态即对象在运行过程中有多种状态，必要条件：a.要有继承关系, b.子类重写父类方法 c.父类引用指向子类对象。
>
> 第三、面向对象编程核心思想：抽象 。提取可公用的。代码的演化就是不断抽象的过程，从多个对象，抽象成一个父类，从多个代码段，抽象出公用方法。从多套流程中抽象出公用的框架。从多个平台抽象出可公用的服务，做成分布式系统，甚至 中台服务。

2.说下你常用的设计模式。

[(7条消息) Java常用的设计模式_qixiang_chen的博客-CSDN博客_java常用的设计模式](https://blog.csdn.net/qixiang_chen/article/details/88381325)

[(7条消息) Java程序员必备，史上最详细常用的八种设计模式讲解丨建议收藏_Java进阶之路的博客-CSDN博客](https://blog.csdn.net/weixin_45039616/article/details/103096625)

> 1.单例模式：懒汉，恶汉，Double Check Lock （DCL）单例
>
> 2.工厂模式
>
> 3.装饰者
>
> 4.代理
>
> 5.适配器
>
> 6.模板方法模式
>
> 7.策略模式

3.讲一下java内存模型（Java Memory Model）

> 这是一种Java虚拟机规范
>
> [Java内存模型（JMM）总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/29881777)
>
> 它定义了主存、工作内存抽象概念、底层对应着CPU寄存器，缓存，硬件内存，CPU指令优化等方面
>
> JMM体现再一下几个方面：
>
> 1. 原子性：保证指令不会收到线程上下文切换的影响
> 2. 可见性：保证指令不会收到CPU缓存的影响
> 3. 有序性：保证指令不会收到CPU指令并行优化的影响，比如指令重排序

4.讲一下jvm内存模型

> 1.线程私有的模型：虚拟机栈（局部变量表，操作数栈，指向常量池的指针），程序计数器，本地方法栈
>
> 2.线程公有的模型：方法区（存字节码文件即类文件）、堆（存对象实例）
>
> 3.java执行引擎：执行解释器，对字节码进行优化，执行GC清理垃圾
>
> 4.类加载器：

5.说一下从编码，到类加载过程

> 1.先说一个整体的过程： 从编码到执行，java文件被javac编译成class文件，通过ClassLoader加载完成，将字节码文件交给执行引擎，然后通过解释器和即时编译器的分析和优化后 进行执行。
>
> 2.然后说道ClassLoader的类加载过程：大体分为3个步骤 Loading - Linking - Initializing
>
>  加载 - 验证 - 准备 - 解析 - 初始化 - 使用 - 卸载
>
> 加载 -- 将.class文件中的二进制字节流读入到JVM
>
> 验证 -- 确保加载进来的字节流符合JVM规范
>
> 准备 -- 为静态变量在方法区分配内存 ， 并设置默认初始值
>
> 解析 -- 将类、方法、属性 等**符号引用**解析为**直接引用**
>
> **初始化**-- 根据程序中的赋值语句 为变量赋值

6.说一下类的初始化

> 什么时候会进行初始化？
>
> 1. new
> 2. 调用类静态字段,方法（final static 字段变量，编译期就被放入常量池）
> 3. 调用反射
>
> 初始化顺序？
>
> 1. 父类静态块和静态变量赋值（按声明顺序）
> 2. 自身静态块和静态变量赋值（安声明顺序）
> 3. 父类成员变量
> 4. 父类构造器（使用super("参数") 可以指定调用父类构造器）
> 5. 自身成员变量
> 6. 自身构造器
>
> 类加载机制？
>
> 1. 全盘负责：当一个类被某类加载器加载后，该类的依赖也都有此类加载器负责加载，除非显示使用另一个类加载器
> 2. 双亲委派：先让父类加载器加载，层层递推，根加载器还是不行，那就再下来，让子加载器加载
> 3. 缓存机制：被加载过的类，存在缓存中，下次调用直接取缓存
>
> 类加载器？
>
> 1. 根类加载器 （BootStrap）：加载一些核心类，rt.jar charset.jar 等核心类和C++实现
> 2. 扩展类加载器 （Extension）：加载扩展jar ，jre/lib/ext包下的 jar 或可由参数指定
> 3. 系统类加载器 （App）：加载classpath指定内容
> 4. 用户类加载器 （Custom）：自定义
>
> 为何双亲委派？
>
>  唯一性，保证加载过的不再加载，安全性，保证某些核心api不会被篡改

7.堆内存空间如何划分，如何回收这些内存对象，有哪些回收算法？

> 1.分为 ：新生代和老年代。 为何这么分：不同的分代存不同类型的对象，方便使用不同的算法分别治理；有些对象生的快死得快，有的对象一直活着；
>
>  新生代留下的对象少，因此可以用复制算法 进行 整理，释放内存空间
>
>  复制到哪里去？因此要给新生代分区，Eden区和Survivor Space (又分From 区To区)
>
>  老年代对象多，使用标记清除算法，大量垃圾对象直接干掉
>
> 2.有哪些回收算法：标记清除，复制、标记整理
>
> 3.为什么再jdk1.8干掉MetaSpace ？

8.常用GC算法

> 1.引用计数法 2.标记清除 3.标记-压缩 4.复制

9.常用垃圾回收器

> 1.serial 收集器 采用xxx算法 串行收集，但会有STW
>
> 2.serial old 是 serial的 老年代版本：采用 标记-整理算法 单线程
>
> 3.parallel scavenge (并行拾荒) ：采用复制算法的并行收集器 也有STW
>
> 4.parallel old 是ps的老年代版本 ：采用 标记-整理 算法的并行收集器
>
> 5.ParNew serial的多线程版本 ：一样存在STW
>
> 6.CMS （concurrent mark sweep）：已最短停顿时间为目标的收集器，基于标记-清除算法，并发收集。运行步骤：初始标记，并发标记，重新标记，并发清除

 垃圾回收器如何选择

> ParNew和ParallelOld不能一起用
>
> 单线程收集器不行，用多线程，但还是有STW，所以出现了CMS，随着当下内存越来越大，导致CMS时碎片太多，因此引用G1
>
> G1（整堆收集器）直接处理新生代和老年代

10.如何解决线上频繁GC的问题

> 1.根据监控，确定问题发生的时间点，根据时间定位，查看版本，是谁提交了什么代码
>
> 2.根据jmap 定位jvm参数
>
> 需补充

11.内存溢出的原因，如何排查

> 引出：什么是内存溢出、什么是内存泄漏？ 溢出是内存超过虚拟机限制，泄漏是内存空间中有一部分没有被利用起来，永远不会被用起来。
>
> 需要在参数中设定，在出现内存溢出的时候，dump出内存快照，便于追踪

12.happen - before 规则？

13.内存屏障的汇编指令

14.有哪些jvm调优实战经验？

### java并发编程相关

1.说一说线程创建的几种方法

> 1. 继承Thread重写run
> 2. 实现Runable接口
> 3. 实现Callable接口
> 4. 使用FutureTask包装Callable，一个可中断，可阻塞等待取回结果的线程工具
>
> 但本质上只有一种方法，即通过Tread对象调其start方法，因为不管是Runable还是线程池，底层的源码都是这种模式。

2.线程执行原理和顺序

> 1. jvm内存结构 : 线程私有（虚拟机栈，本地方法栈，PC寄存器），共有（堆，方法区）
> 2. 每一个线程启动时都会有一个栈，每调用一个方法创建一个活动栈帧，栈帧中包含（局部变量表，返回地址，锁记录，操作数栈）
> 3. 程序计数器去方法区获取指令
> 4. 获取到main方法，创建main栈帧，参数读入局部变量表，并记录返回地址
> 5. 获取下一条指令

3.如何判断是否线程安全和线程不安全

> 看是否共享，是否有写操作；例如静态变量一般都是共享的，但如果这个变量只读，那线程安全。但如果有写操作，那线程不安全

3.工作线程数，或线程池中线程数 设置多少合适？ 
$$
N = Ncpu(核数) * Ucpu(期望cpu利用率) * (1+W(线程等待时间)/C(线程执行时间))
$$
​	 其中W/C怎么计算? 使用软件测算 Profiler测试；但如果实际环境和压测不一样呢？可以用Arthas监控。

4.Synchronize的底层实现

![](..\图片\image-20210511154542728.png)

> 首先要知道，对象头：32位虚拟机，对象头markword有64位（8字节）,4个字节是MarkWord，另外4个字节是 KlassWord
>
> MarkWord(4字节，32位)：25位 HashCode，4位 分代年龄，2位 是否偏向 ，2位 锁状态。
>
> Monitor（锁）：Monitor被翻译为 **监视器** 或者 **管程** ，每个java对象都可以关联一个Monitor对象，此对象中有三个区域 Owner，EntrySet，WaitSet。
>
> 刚开始Monitor中的Owner位null 当线程执行到Sychronized代码块时，就会将Onwer置位占有线程，MarkWord中的hashCode被替换为对应的Monitor对象地址
>
> 在上锁状态时，其他线程来访问锁，会进入EntrySet，直到站有锁线程执行完，EntrySet中线程竞争获取Owner位置。
>
> Wait/Notify的原理：当线程获得锁，但又不满足某些条件时，调用wait方法使其进入waitSet进行等待，直到被Owner线程唤醒notify/notifyAll，再从waitSet进入EntryList一起等待竞争锁。

5.锁升级的过程

> 1. 轻量级锁：一个资源多线程访问，但访问时间是错开的，那么使用轻量级锁；
>
> 2. 创建锁记录：每个线程的栈帧都会包含一个锁记录，当一个对象要上锁时，去栈帧中存储自己的对象引用，并将锁记录中存储的 锁记录地址 信息和MarkWord中的对象hashcode等交换，即CAS
>
> 3. 如果上锁失败：即MarkWord中的锁状态不是01, 那进入 **锁膨胀** 或者 **锁重入**。
>
> 4. 锁膨胀：当某对象的MarkWord中的地址已被Thread1替换为00即轻量级锁，此时另一个线程2来请求共享资源，访问这把锁，请求失败；则为当前锁对象申请一个Monitor对象，并将对象中的MarkWord改为重量级锁的地址，然后Thread2进入Monitor的EntryList，上锁完成。当Thread1要解锁时，先尝试直接交换锁记录和MarkWord但发现无法交换，因为此时不是轻量级锁，锁状态为不是01，所以走重量级锁的解锁流程
>
> 5. 自旋优化：当T1已经上了重量级锁的时候，T2来竞争锁，会先进行几次自旋等待，自旋等待成功直接上锁，失败则进入EntryList(多核Cpu自旋才有意义)
>
> 6. 偏向锁：java6引入对锁进一步优化，多次锁重入时，每次进行CAS有点浪费性能。因此进入偏向锁，直接将MarkWord中写上当前线程Id。默认启用偏向锁的
>
> 7. 偏向锁撤销
>
>    几个参数：
>
> ```java
> //关闭延迟开启偏向锁
> -XX:BiasedLockingStartupDelay=0
> //禁止偏向锁
> -XX:-UseBiasedLocking 
> //启用偏向锁
> -XX:+UseBiasedLocking 
> ```
>
> ​		当一个可偏向的对象上锁前，调用一下对象的hashCode方法，会禁用偏向锁，因为偏向对象的MarkWord没		地方存储HashCode.
>
> ​		当有竞争的时候，且没有交错竞争，撤销偏向，**升级为轻量级锁**
>
> ​		当调用wait/Notify的时候，撤销偏向，**升级为重量级锁**
>
>  8. 批量重偏向  多个锁已被设置偏向状态后，再被另一个线程调用，偏向另一个线程超过20，剩下的所有都批量改为偏向另一个线程。
>
>  9. 批量撤销 超过39次
>
>  10. 锁消除
>
>      因为即时编译器的存在，代码中的热点代码可能会被进行锁消除的优化，synchronized代码可能被优化掉。可通过参数设定 java -XX:-EliminateLocks
>

6.Synchronized的可重入特性

> 一个类中的两个方法都加锁了，使用同一把锁即锁定同一个对象，一个线程，调用，方法1，方法1中又调用了方法2，当前被锁定对象发现是同一个线程，那么允许再次上锁。

7.wait(n)和sleep(n)的区别

> 1. sleep是Thread的静态方法，wait是Object的方法
> 2. wait需要配合Synchronize一起用
> 3. Sleep等待是不会释放锁的，wait会释放

8.Join的原理

> 1. （同步模式）保护性暂停模式：使用一个对象进行中间的协调者，在其中可有容器对象，get方法，set方法，利用wait和notify组合使用

9.生产者消费者模式（异步模式）

> 与保护暂停模式不同的是：不需要产生结果和消费结果的线程一一对应
>
> 队列有容量限制，可以平衡生产和消费

10.Wait/Notify和Park/UnPark的区别

> 1. wait/notify需要配合Monitor才能枷锁
> 2. notify只能随机唤醒某个等待区的线程，notifyAll能唤醒所有，不精确，unPark能指定唤醒某线程
> 3. unPark能先于Park执行，也能唤醒线程

11.park/unPark原理

![image-20210512175225489](..\图片\image-20210512175225489.png)

> ​		每一个线程包含一个Parker对象，其中包含_mutex对象，和_counter计数器，mutex对象中包含_cond数组

12.线程的活跃性

> 1. 死锁：两个线程互相持有对方的锁，死锁
> 2. 定位死锁： jstack, jconsole 查看block状态的线程
> 3. 哲学家就餐问题：五个人，5只筷子，最后，一人拿着一只筷子等待别人放下筷子，导致死锁
> 4. 活锁：两个线程改变了对方的结束条件，谁也停不下来
> 5. 饥饿：有一种解释是某些线程由于优先级低而长时间无法获得锁；还有一种出现饥饿的情况是，当为了解决死锁问题而使用顺序加锁方案的时候，很有可能出现饥饿，就比如哲学家就餐时，拿筷子都按顺序拿。
>
> 如何解决死锁，活锁，饥饿？ 使用超时机制，避免无限制等待。

13.ReentrantLock和Synchronize比的优势

> 1. 支持公平锁
> 2. 可以有多个条件变量，多个WaitSet，精准唤醒，防止虚假唤醒
>    1. 虚假唤醒：notifyAll 使用时不能精确唤醒，会唤醒WaitSet中的所有线程，所以有的线程并不满足条件也被唤醒的，叫虚假唤醒。
> 3. 可打断

14.同步模式--交替输出

> 1. 使用wait/notify
>
>    1. 关键在于设置一个int类型标记位，用while判断当前执行线程是否和标记一致，如果一致才放行，执行完后将标记位改为下一顺序位的线程，再notifyAll叫醒所有等待线程。
>
>    ```java
>    /**
>    *Wait Notify的方式 demo
>    **/
>    public class demo{
>        public static void main(String[] args){
>            
>        }
>    }
>    
>    public class WaitNotify(){
>        //等待标记 int
>        private int flag;
>        //循环次数 int
>        private int loopNumber;
>        public void print(String printStr, int waitFlag, int nextFlag){
>            for(int i=0 ; i< loopNumber; i++){
>                synchronized(this){
>                //while判断，防止虚假唤醒    
>                while(flag!= waitFlag){
>                    try{
>                        //先等待
>                        this.wait();
>                    }catch(Exception e){
>                        e.printStackTrace;
>                    }
>                    //被叫醒后打赢
>                    System.out.print(printStr);
>                    //让标记改为下一个标记，让下一个线程继续运行
>                    flag = nextFlag;
>                    this.notifyAll();
>                }
>            }
>            }
>        }
>        
>        //构造方法
>        public WaitNotify(int flag, int loopNumber){
>            this.flag = flag;
>    		this.loopNumber = loopNumber;        
>        }
>    }
>    ```
>
> 2. 使用ReentrantLock
>
>    1. 使用RenntrantLock的可设置多个等待条件特性，new Condition 来设置多个WaitSet，并且进行精准唤醒
>
> 3. Park/UnPark 
>
>    1. 这种方法的好处是，一上来使用Park可以同时Park所有线程，但使用unPark时可以精准唤醒某线程

14.可重入锁和不可重入锁都有哪些

15.Volatile的作用

>  1. 保证可见性
>   	1. Balking模式、犹豫模式     使用一个状态标记，作为主线程和其他线程之间的信号，当一个线程改变这个标记时，用Volatile可以保证该标记同步到其他线程的内存空间中
>  2. 保证有序性-禁止指令重排
>   	1. 什么是指令重排？CPU执行指令分5步骤： 取指令 - 指令译码 - 指令执行 - 内存访问 - 数据写回； 现在的CPU支持多级指令流水线，以上5个步骤其实可以同时执行，变相的提高指令执行的吞吐量（并行度）。因此在**多条指令 并行 执行** 指令的时候，相当于执行次序会被CPU调整。
>   	2. 指令重排的前提：重排之后，不影响结果，如果下一条指令依赖上一条指令的结果，就不能并行
>   	3. 如何避免指令重排：使用Volatile加在不想发生重排的赋值语句后面，生成一个写屏障。
> 3. Volatile的原理 -- **内存屏障**是怎么保证 指令的 可见性 和 有序性 的
>   1. 内存屏障原理：在Volatile修饰的变量 的 **写指令 -- 后** 加入**写屏障**；在**读指令 -- 前** 加入 **读屏障**
>   2. 读屏障之后的内容，保证读取主存；写屏障之前的内容，保证读取主存
>   3. 写屏障之前的指令 保证不会出现在写屏障 之后；读屏障之后的 指令 保证不会出现在读屏障到后面
> 4. DCL单例中的指令重排序问题：创建对象的几个字节码指令有可能重排，导致 引用先指向了空对象，然后才执行构造方法给对象赋值  。所以另一个线程有可能直接返回了一个空对象。

16.Happens - Before 规则

> 定义：因为JVM会对代码进行编译优化，指令会出现重排序的情况，为了避免编译优化对并发编程安全性的影响，需要happens-before规则定义一些禁止编译优化的场景，保证并发编程的正确性。
>
> 1. sychornized块内的代码保证可见性
> 2. Volatile修饰的变量保证可见性
> 3. 线程开始后和结束后
> 4. 线程被打断，打断前的修改 可见
> 5. 变量默认值 可见
> 6. Volatile的传递性

17.CAS与Volatile

> CompareAndSet / CompareAndSwap 比较并交换， 是一种乐观锁。 如果枷锁失败就循环重试，直到成功为止。在Inter的CPU中，使用cmpxchg指令实现
>
> **实现原理** ：CAS(旧值，预期值) ，用参数中的旧值 与 主存 中的值 进行比较，如果相等，则进行交换，如果不相等，则自旋。
>
> ```java
> AtomicInteger i = new AtomicIntger();
> while(true){
>  int current = i.get();//当前最新值
>  int expect = current + 10;//期待值
>  if(i.compareAndSet(current , expect )){
>      //如果交换成功，break跳出循环
>      break;
>  }
> }
> ```
>
> 因为CAS操作必须要获取到最新值，所以，需要使用Volatile保证变量的可见性
>
> 适用场景：线程数少，多核CPU的场景下，乐观锁模式
>
> **CAS底层实现**：Unsafe对象中的cas操作方法，Unsafe底层是直接调用了CPU的lock打头的指令

18.为什么CAS的效率比Sync高

> CAS不会让线程停下来，但需要是多核CPU的时候，因为你是单核，还是会切换时间片
>
> 而Sync进行状态转换的时候，每次都在进行上下文切换

19.常用原子类型有哪些？原理是什么

> 1. 原子整数 AtomicInteger  getAndIncrement()   ,   getAndUpdate() 原理都是CAS 
> 2. 原子引用AtomicRefrence
> 3. 原子数组 AtomicIntegerArray , AtomicReferenceArray
> 4. 原子更新器 AtomicReferenceFiledUpdater 保护对象的成员变量的线程安全性
> 5. 原子累加器 JDK1.8以后新增了 LongAdder 和 LongAccumulator 他俩性能更强
>
> 原子类型底层 也是使用了 CAS + volatile维护一个Value值

20.ABA问题是什么，怎么解决？

> CAS过程中，只会判断当前值和主存的当前值是否一致，但不知道是否有其他线程改过这个值，也许它现在是A，但其实它是经历过线程2将他改为了B,又经历了线程3将他改回了A
>
> 解决：增加版本号，使用类AtomicStampedReference
>
> 不想知道改了几次，只想知道改了没改，使用AtomicMarkbleReference

21.什么是缓存行伪共享 -- 或者缓存行对齐？

> 1. 什么叫**缓存行**：CPU的结构是这样的，每个内核有自己独立的L1,L2还有内核之间共享的三级缓存，再下来就是内存，缓存的最小单位就是缓存行，一般是64byte 8个long那么大
> 2. 缓存行的优缺点：优点就是用多级缓存来提升性能，因为CPU直接读取内存的速度太慢了，缺点是，会造成多份副本数据---一份数据会在不同核心的缓存行中出现。**因此**为了保持数据一致，如果某个核心修改了该缓存行数据，那么在另一个核心中的**整个缓存行副本则会失效**。
> 3. 解决：使用**@contented**注解，会给对象或字段填充padding保证关键数据独占一个缓存行，互不干扰

22.线程池的运行原理

> 两个集合，一个任务集合，一个线程集合

22.线程池的七个参数

> 1. corePoolSize
> 2. maximumPoolSize
> 3. keepAliveTime
> 4. timeUnit
> 5. workQueue
> 6. threadFactory
> 7. rejedctHandler

23.线程流转的过程

> 1. 第一个任务来时，启动核心线程 ，任务结束，核心线程不会回收
> 2. 核心线程满，任务进入等待队列，任务队列满，启动救急线程
> 3. 当最大线程数满，救急线程也满，执行拒绝策略

24.常用线程池

> 1. newFixedThreadPool  没有救急线程，使用无界队列
> 2. CachedThreadPool  没有核心线程，使用SynchronousQueue同步队列，即没有等待队列，任务来了就创建线程
> 3. SingleThreadPool  只有一个核心线程，使用无界队列，用来顺序执行任务，且某一个线程任务失败，还是会继续执行下一个任务
> 4. scheduledThreadPool 定时执行线程池

25.如何处理线程池异常







8.JUC包的其他同步锁工具有哪些了解

9.说一下并发容器类

​	ConcureentHshMap

​	 2.HashMap为什么使用红黑树？

> 连续元素超过8将后面的数据存在红黑树中 ，便于检索

10.常用线程池和自定义线程池的使用和原理

11.如何预防死锁

> 什么是死锁？资源有限，

### Spring相关

1.谈谈对Spring IOC 原理

> 控制反转就是把对象的创建工作交给Spring容器来做，根据配置文件或者注解，利用反射，在运行期动态的创建对象。
>
> 要说清出原理，就需要从Spring **容器的初始化过程**说起。
>
> 总的来说分为4步骤：
>
> 1. 读取bean的配置信息，从xml，或者从java配置类，或者从注解，生成一个bean的注册表。
>    1. ResourceLoader从配置文件中读取信息，生成Resource对象
>    2. BeanDefinitionReader读取Resource,解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistry中
>    3. BeanDefinition对象经过BeanFactoryPostProcesser加工处理（处理一些占位符等，这里还是扩展点）
> 2. 根据bean注册表实例化bean
> 3. 将实例化的bean放到Spring容器中，其实就是一个Map<name, beanDefinition>集合
>    1. 创建beanFactory，getBean方法获取
> 4. 应用程序，使用bean

2.bean的生命周期

> 1. 根据beanDefinition对象进行具体的实例化操作
> 2. doCreateBean通过反射的方式创建对象
> 3. populateBean填充属性, 其中需要创建需要依赖的Bean对象（这里会产生循环依赖问题）
> 4. initializeBean进行初始化Bean
>    1. 设置aware接口属性
>    2. beanPostProcesser.before方法
>    3. 执行init-methord
>    4. beanPostProcesser.after方法 实质上就是AOP的原理
>    5. contex.getBean()获取到对象
> 5. 得到对象后，进行对象相关操作
> 6. 销毁对象
>    1. 可以实现一些自自定义的销毁对象时触发的方法

3.循环依赖问题是什么？以及怎么解决？

> 要突出的点：**三级缓存**； **提前暴露对象**； **AOP**
>
> 1. 什么是循环依赖？
>
>    1. A对象中需要注入B对象作为属性,B对象中需要注入A对象作为属性
>    2. bean的创建过程，实例化，初始化，初始化中需要进行填充属性。填充属性过程中创建A需要B,但容器中没有B就需要创建B对象，但B对象中会有A属性，于是又需要创建A对象，形成一个死循环。
>
> 2. 如何解决循环依赖？
>
>    1. 要解决这个问题就需要打断上面的闭环，把已实例化，但未初始化完成的不完整对象，提前暴露出来。某位置存放完整对象，某位置存放不完整对象
>    2. 所以需要不同的Map结构来存储这些不同类型的对象，此时就出现了一级缓存和二级缓存
>    3. 对象实例化完成，就先放到二级缓存中去，实例化完成就移除二级缓存，放入1级缓存
>    4. 一级缓存中存放完整对象，二级缓存中存放不完整对象
>    5. 加载对象的顺序就是，1,2,3级缓存的顺序去找
>   6. 三级缓存就是为了保持容器中的对象唯一性。
>          1. 在进行Aop的时候，有些对象需要进行动态代理，因为在进行代理之前其实还是要实例化对象的，所以，要保证这个对象的唯一性，需要三级缓存。
>

4.BeanFactory和FactoryBean的区别

> 相同点：都是创建对象用的
>
> 不同点：使用BeanFactory创建对象的时候，提供一个SpringIOC容器规范，必须要遵循严格的bean创建生命周期，太复杂了。如果想要简单的自定义某个对象的创建，同时创建完成的对象交给Spring来管理，那么需要实现FactoryBean接口。其中有三个方法：
>
> 1. isSingleton 是否单例
> 2. getObjectType获取返回的对象的类型
> 3. getObject自定义创建对象的过程（new,反射，动态代理）

5.Spring的 AOP的实现原理

> 原理是动态代理，先有的IOC再有的AOP，AOP是IOC的一个扩展功能，BeanPostProcessor
>
> ​	bean的创建过程中有一个步骤可以对bean进行扩展实现，即BeanPostProcessor
>
> ​	如何来进行实现的？
>
> 1. 代理对象的创建过程
> 2. 通过jdk或cglib的方式来生成代理对象

6.Spring的事务是如何回滚的

7.Spring 事务隔离级别

### MySQL相关





### 分布式相关

### 运维与Linux相关

