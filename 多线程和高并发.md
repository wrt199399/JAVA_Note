---
typora-root-url: ./
---

# 一、基础部分

## 1.线程执行原理

**栈与栈帧**

Java Virtual Machine Stacks （Java 虚拟机栈）

我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟

机就会为其分配一块栈内存。

每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存

每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

![](/图片/image-20200416202834866.png)

## 2.创建线程的方式

继承Thread，实现Runnable，线程池 

```java
public class T02_HowToCreateThread {
    static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println("Hello MyThread!");
        }
    }

    static class MyRun implements Runnable {
        @Override
        public void run() {
            System.out.println("Hello MyRun!");
        }
    }

    public static void main(String[] args) {
        new MyThread().start();
        new Thread(new MyRun()).start();
        new Thread(()->{
            System.out.println("Hello Lambda!");
        }).start();
        
    }

}
//Executors.newCachedThreadPool
```

​    不同的写法：

Lambda

`Runnable task2 = () -> log.debug("hello");`

```java
public static void main(String[] args) {
		T t = new T();
		
		/*new Thread(()->t.m1(), "t1").start();
		new Thread(()->t.m2(), "t2").start();*/
		
		new Thread(t::m1, "t1").start();//这也是一种lambda的写法
		new Thread(t::m2, "t2").start();
		
		/*
		//1.8之前的写法
		new Thread(new Runnable() {
			@Override
			public void run() {
				t.m1();
			}
			
		});
		*/
		
	}
```



## 3.查看线程的方式

> jstack <PID> 查看某个 Java 进程（PID）的所有线程状态
>
> jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）
>
> jconsole 远程监控配置:
>
> 需要以如下方式运行你的 java 类
>
> 修改 /etc/hosts 文件将 127.0.0.1 映射至主机名
>
> 如果要认证访问，还需要做如下步骤
>
> 复制 jmxremote.password 文件
>
> 修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写
>
> 连接时填入 controlRole（用户名），R&D（密码）

## 4.sleep_yield_join

sleep 让出cpu时间片一定时间

yield 让出时间片一瞬间

join 如果在t1线程中执行t2.join，代表将t2加入到当前线程，等待t2执行完成，继续从当前点执行t1

## 5.sychronized

### 1）简单概括

sychronized可以加在代码块中锁this，可以加在实例方法上锁的也是this

可以加在静态方法，锁的是当前Class对象

```java
/**
 * synchronized关键字
 * 对某个对象加锁
 * @author mashibing
 */

package com.mashibing.juc.c_002;

public class T {
	
	private int count = 10;
	
	public void m() {
		synchronized(this) { //任何线程要执行下面的代码，必须先拿到this的锁
			count--;
			System.out.println(Thread.currentThread().getName() + " count = " + count);
		}
	}
    
    public synchronized void  m() {//等同于在方法的代码执行时要synchronized(this)
			count--;
			System.out.println(Thread.currentThread().getName() + " count = " + count);
	}
	
}
```

### 2）锁重入

子类调用父类的同步方法的情形

### 3）遇到异常锁会被释放

```java
/**
 * 程序在执行过程中，如果出现异常，默认情况锁会被释放
 * 所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。
 * 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，
 * 在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。
 * 因此要非常小心的处理同步业务逻辑中的异常
 * @author mashibing
 */
package com.mashibing.juc.c_011;

import java.util.concurrent.TimeUnit;

public class T {
	int count = 0;
	synchronized void m() {
		System.out.println(Thread.currentThread().getName() + " start");
		while(true) {
			count ++;
			System.out.println(Thread.currentThread().getName() + " count = " + count);
			try {
				TimeUnit.SECONDS.sleep(1);
				
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			if(count == 5) {
				int i = 1/0; //此处抛出异常，锁将被释放，要想不被释放，可以在这里进行catch，然后让循环继续
				System.out.println(i);
			}
		}
	}
	
	public static void main(String[] args) {
		T t = new T();
		Runnable r = new Runnable() {

			@Override
			public void run() {
				t.m();
			}
			
		};
		new Thread(r, "t1").start();
		
		try {
			TimeUnit.SECONDS.sleep(3);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		new Thread(r, "t2").start();
	}
	
}
```

### 4）底层实现

synchronized的底层实现
JDK早期的 重量级 - OS
后来的改进(jdk1.6以后)
锁升级的概念：
    我就是厕所所长 （一 二）

sync (Object)
markword 记录这个线程ID （偏向锁）
如果线程争用：升级为 自旋锁
10次以后，
升级为重量级锁 - OS

执行时间短（加锁代码），线程数少，用自旋
执行时间长，线程数多，用系统锁

### 5）锁优化

细化：同步代码块中的语句约少越好

锁定字符串对象：不要锁定字符串对象，因为字符串引用指向的都是常量池中的对象，有可能多个方法使用了同一把锁，而你却不知道

锁定对象：不要改变对象的引用，不然相当于重新上锁

## 6.Volatile

### 1）保证线程间可见性

```java
/**
 * volatile 关键字，使一个变量在多个线程间可见
 * A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道
 * 使用volatile关键字，会让所有线程都会读到变量的修改值
 * 
 * 在下面的代码中，running是存在于堆内存的t对象中
 * 当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去
 * 读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行
 * 
 * 使用volatile，将会强制所有线程都去堆内存中读取running的值
 * 
 * 可以阅读这篇文章进行更深入的理解
 * http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html
 * 
 * volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized
 * @author mashibing
 */
package com.mashibing.juc.c_012_Volatile;

import java.util.concurrent.TimeUnit;

public class T01_HelloVolatile {
	/*volatile*/ boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别
	void m() {
		System.out.println("m start");
		while(running) {
		}
		System.out.println("m end!");
	}
	
	public static void main(String[] args) {
		T01_HelloVolatile t = new T01_HelloVolatile();
		
		new Thread(t::m, "t1").start();

		try {
			TimeUnit.SECONDS.sleep(1);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		t.running = false;
	}
	
}
```

1) volatile 引用类型（包括数组）只能保证引用本身的可见性，不能保证内部字段的可见性

2) volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized

3）归根结底，使用的是硬件层面，缓存一致性协议

4）volatile可以保证可见性，但不能替代synchronized保证原子性

### 2）禁止指令重排序

编译器编译代码后，在汇编层面，可能会把代码重新排序

应用：DCL(double check lock)单例模式

```java
public class Test2 {
    private static /*volatile*/ Test2 INSTANCE;
    private Test2(){
    }
    public static Test2 getInstance(){
        if(INSTANCE==null){
            //双重检查
            synchronized(Test2.class){
                if(INSTANCE==null){
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    INSTANCE = new Test2();
                }
            }
        }
        return INSTANCE;
    }
}

```

面试题：

单例模式中的，DCL单例要不要加volatile?

答：要加，因为对象初始化的过程中很有可能发生指令重排，导致半初始化状态的对象出现。这个时候第二个线程过来拿对象，此时，INCSTANCE!=null ，就会得到一个半初始化状态的对象。此情况在超高并发的状态会出现。

相关内容：对象的初始化过程，有可能也会被问到

如何先的禁止指令重排？ 加了内存屏障，读写屏障 loadfence原语指令，storefence愿语指令

## 7.AtomicInteger

通过cas保证线程安全类 java.util.concurrent.atomic 包下的类

```java
/**
 * 解决同样的问题的更高效的方法，使用AtomXXX类
 * AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的
 * @author mashibing
 */
package com.mashibing.juc.c_018_00_AtomicXXX;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;


public class T01_AtomicInteger {
	/*volatile*/ //int count1 = 0;
	
	AtomicInteger count = new AtomicInteger(0); 

	/*synchronized*/ void m() { 
		for (int i = 0; i < 10000; i++)
			//if count1.get() < 1000
			count.incrementAndGet(); //count1++
	}

	public static void main(String[] args) {
		T01_AtomicInteger t = new T01_AtomicInteger();

		List<Thread> threads = new ArrayList<Thread>();

		for (int i = 0; i < 10; i++) {
			threads.add(new Thread(t::m, "thread-" + i));
		}

		threads.forEach((o) -> o.start());

		threads.forEach((o) -> {
			try {
				o.join();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		});

		System.out.println(t.count);

	}

}
```

AtomicLong 和LongAdder 和synchronize的效率对比代码

```java
package com.mashibing.juc.c_018_00_AtomicXXX;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

public class T02_AtomicVsSyncVsLongAdder {
    static long count2 = 0L;
    static AtomicLong count1 = new AtomicLong(0L);
    static LongAdder count3 = new LongAdder();

    public static void main(String[] args) throws Exception {
        Thread[] threads = new Thread[1000];

        for(int i=0; i<threads.length; i++) {
            threads[i] =
                    new Thread(()-> {
                        for(int k=0; k<100000; k++) count1.incrementAndGet();
                    });
        }

        long start = System.currentTimeMillis();

        for(Thread t : threads ) t.start();

        for (Thread t : threads) t.join();

        long end = System.currentTimeMillis();

        //TimeUnit.SECONDS.sleep(10);

        System.out.println("Atomic: " + count1.get() + " time " + (end-start));
        //-----------------------------------------------------------
        Object lock = new Object();

        for(int i=0; i<threads.length; i++) {
            threads[i] =
                new Thread(new Runnable() {
                    @Override
                    public void run() {

                        for (int k = 0; k < 100000; k++)
                            synchronized (lock) {
                                count2++;
                            }
                    }
                });
        }

        start = System.currentTimeMillis();

        for(Thread t : threads ) t.start();

        for (Thread t : threads) t.join();

        end = System.currentTimeMillis();


        System.out.println("Sync: " + count2 + " time " + (end-start));


        //----------------------------------
        for(int i=0; i<threads.length; i++) {
            threads[i] =
                    new Thread(()-> {
                        for(int k=0; k<100000; k++) count3.increment();
                    });
        }

        start = System.currentTimeMillis();

        for(Thread t : threads ) t.start();

        for (Thread t : threads) t.join();

        end = System.currentTimeMillis();

        //TimeUnit.SECONDS.sleep(10);

        System.out.println("LongAdder: " + count1.longValue() + " time " + (end-start));

    }

    static void microSleep(int m) {
        try {
            TimeUnit.MICROSECONDS.sleep(m);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}
```

效率对比 ： longAdder > atomicLong > sync

为何LongAdder最快？LongAdder用了分段锁 。将大量线程的递增操作分而治之，最后求总和



## 8.CAS(无锁优化，乐观锁，自旋)

1）Compare And Set /Swap

cas(实际值V，期望值E，新值NewVal)

if  V==E  

赋值V = NewVal

否则重试，重新将期望值替换，再进行新值的赋值

cas是cpu愿语支持，中间不能打断

2）ABA问题

加版本号限定

A1.0

B2.0

A3.0

## 9.Unsafe类

其中 compareAndSwap 方法用的就是cas 

Unsafe中有 allocateMemory方法 直接分配内存

Unsafe类 类似于C++中的指针



## 10.ReentrantLock

### 1）介绍

可重入锁的一种，synchronize 也是一种

```java
/**
 * reentrantlock用于替代synchronized
 * 由于m1锁定this,只有m1执行完毕的时候,m2才能执行
 * 这里是复习synchronized最原始的语义
 * 
 * 使用reentrantlock可以完成同样的功能
 * 需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）
 * 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放
 * @author mashibing
 */
package com.mashibing.juc.c_020;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class T02_ReentrantLock2 {
	Lock lock = new ReentrantLock();

	void m1() {
		try {
			lock.lock(); //synchronized(this)
			for (int i = 0; i < 10; i++) {
				TimeUnit.SECONDS.sleep(1);

				System.out.println(i);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}

	void m2() {
		try {
			lock.lock();
			System.out.println("m2 ...");
		} finally {
			lock.unlock();
		}

	}

	public static void main(String[] args) {
		T02_ReentrantLock2 rl = new T02_ReentrantLock2();
		new Thread(rl::m1).start();
		try {
			TimeUnit.SECONDS.sleep(1);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		new Thread(rl::m2).start();
	}
}
```

### 2）用法

`tryLock(Time)`

使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待。

`lockInterruptibly()`

给当前线程加一个可以被打断的锁。当另一个线程执行t1.interrupt方法的时候可以打断当前的等待。

`new Reentrantlock(true)` 

公平锁，在构造方法中传递参数true代表这是一个公平锁，先来后到的顺序获得锁

### 3）ReentrantLock   与 Synchronize的区别

Sync只有非公平锁，ReentrantLock可以设置公平非公平

Sync没有trylock和lockInterruptibly

## 11.CountDownLatch 

```java
 private static void usingCountDownLatch() {
        Thread[] threads = new Thread[100];
        CountDownLatch latch = new CountDownLatch(threads.length);

        for(int i=0; i<threads.length; i++) {
            threads[i] = new Thread(()->{
                int result = 0;
                for(int j=0; j<10000; j++) result += j;
                latch.countDown();
            });
        }

        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }

        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("end latch");
    }
```

倒数门栓，用来等待线程结束，然后做某事



## 12.CyclicBarrier

循环的栅栏，人满了，栅栏推倒，执行程序

等线程计数到规定值，执行某段程序

## 13.Phaser