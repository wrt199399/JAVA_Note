---
typora-root-url: ./
---

# 一、基本概念

## 1.线程执行原理

**栈与栈帧**

Java Virtual Machine Stacks （Java 虚拟机栈）

我们都知道 JVM 中由堆、栈、方法区所组成，其中**栈内存**是给谁用的呢？其实就是线程，每个线程启动后，虚拟

机就会为其分配一块栈内存。

每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存

每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

![](/图片/image-20200416202834866.png)

## 2.创建线程的方式

继承Thread，实现Runnable，线程池 

```java
public class T02_HowToCreateThread {
    static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println("Hello MyThread!");
        }
    }

    static class MyRun implements Runnable {
        @Override
        public void run() {
            System.out.println("Hello MyRun!");
        }
    }

    public static void main(String[] args) {
        new MyThread().start();
        new Thread(new MyRun()).start();
        new Thread(()->{
            System.out.println("Hello Lambda!");
        }).start();
        
    }

}
//Executors.newCachedThreadPool
```

​    不同的写法：

Lambda

`Runnable task2 = () -> log.debug("hello");`

```java
public static void main(String[] args) {
		T t = new T();
		
		/*new Thread(()->t.m1(), "t1").start();
		new Thread(()->t.m2(), "t2").start();*/
		
		new Thread(t::m1, "t1").start();//这也是一种lambda的写法
		new Thread(t::m2, "t2").start();
		
		/*
		//1.8之前的写法
		new Thread(new Runnable() {
			@Override
			public void run() {
				t.m1();
			}
			
		});
		*/
		
	}
```



## 3.查看线程的方式

> jstack <PID> 查看某个 Java 进程（PID）的所有线程状态
>
> jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）
>
> jconsole 远程监控配置:
>
> 需要以如下方式运行你的 java 类
>
> 修改 /etc/hosts 文件将 127.0.0.1 映射至主机名
>
> 如果要认证访问，还需要做如下步骤
>
> 复制 jmxremote.password 文件
>
> 修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写
>
> 连接时填入 controlRole（用户名），R&D（密码）

## 4.sleep_yield_join

sleep 让出cpu时间片一定时间

yield 让出时间片一瞬间

join 如果在t1线程中执行t2.join，代表将t2加入到当前线程，等待t2执行完成，继续从当前点执行t1

# 二、sychronized

### 1）简单概括

sychronized可以加在代码块中锁this，可以加在实例方法上锁的也是this

可以加在静态方法，锁的是当前Class对象

```java
/**
 * synchronized关键字
 * 对某个对象加锁
 * @author mashibing
 */

package com.mashibing.juc.c_002;

public class T {
	
	private int count = 10;
	
	public void m() {
		synchronized(this) { //任何线程要执行下面的代码，必须先拿到this的锁
			count--;
			System.out.println(Thread.currentThread().getName() + " count = " + count);
		}
	}
    
    public synchronized void  m() {//等同于在方法的代码执行时要synchronized(this)
			count--;
			System.out.println(Thread.currentThread().getName() + " count = " + count);
	}
	
}
```

### 2）锁重入

子类调用父类的同步方法的情形

### 3）遇到异常锁会被释放

```java
/**
 * 程序在执行过程中，如果出现异常，默认情况锁会被释放
 * 所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。
 * 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，
 * 在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。
 * 因此要非常小心的处理同步业务逻辑中的异常
 * @author mashibing
 */
package com.mashibing.juc.c_011;

import java.util.concurrent.TimeUnit;

public class T {
	int count = 0;
	synchronized void m() {
		System.out.println(Thread.currentThread().getName() + " start");
		while(true) {
			count ++;
			System.out.println(Thread.currentThread().getName() + " count = " + count);
			try {
				TimeUnit.SECONDS.sleep(1);
				
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			if(count == 5) {
				int i = 1/0; //此处抛出异常，锁将被释放，要想不被释放，可以在这里进行catch，然后让循环继续
				System.out.println(i);
			}
		}
	}
	
	public static void main(String[] args) {
		T t = new T();
		Runnable r = new Runnable() {

			@Override
			public void run() {
				t.m();
			}
			
		};
		new Thread(r, "t1").start();
		
		try {
			TimeUnit.SECONDS.sleep(3);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		new Thread(r, "t2").start();
	}
	
}
```

### 4）底层实现

synchronized的底层实现
JDK早期的 重量级 - OS
后来的改进(jdk1.6以后)
锁升级的概念：
    我就是厕所所长 （一 二）

sync (Object)
markword 记录这个线程ID （偏向锁）
如果线程争用：升级为 自旋锁
10次以后，
升级为重量级锁 - OS

执行时间短（加锁代码），线程数少，用自旋
执行时间长，线程数多，用系统锁

### 5）锁优化

细化：同步代码块中的语句约少越好

锁定字符串对象：不要锁定字符串对象，因为字符串引用指向的都是常量池中的对象，有可能多个方法使用了同一把锁，而你却不知道

锁定对象：不要改变对象的引用，不然相当于重新上锁



### 6）wait,notify/notifyAll

**锁池：**

假设线程A已经拥有了某个对象（不是类）的锁，而其它线程B,C想要调用这个对象的某个某个synchronized方法(或者块)之前必须获得该对象锁的拥有权，而恰巧该对象的锁目前正被A所占有，此时B， C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池。

**等待池**

  假设线程A调用了某个对象的wait方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入等待池中的线程不会去竞争该对象的锁。

 **notify和notifAll的区别**

notifyAll： 会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会

notify： 只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会。

notify的随机选取策略？

# 三、Volatile

### 1）保证线程间可见性

```java
/**
 * volatile 关键字，使一个变量在多个线程间可见
 * A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道
 * 使用volatile关键字，会让所有线程都会读到变量的修改值
 * 
 * 在下面的代码中，running是存在于堆内存的t对象中
 * 当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去
 * 读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行
 * 
 * 使用volatile，将会强制所有线程都去堆内存中读取running的值
 * 
 * 可以阅读这篇文章进行更深入的理解
 * http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html
 * 
 * volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized
 * @author mashibing
 */
package com.mashibing.juc.c_012_Volatile;

import java.util.concurrent.TimeUnit;

public class T01_HelloVolatile {
	/*volatile*/ boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别
	void m() {
		System.out.println("m start");
		while(running) {
		}
		System.out.println("m end!");
	}
	
	public static void main(String[] args) {
		T01_HelloVolatile t = new T01_HelloVolatile();
		
		new Thread(t::m, "t1").start();

		try {
			TimeUnit.SECONDS.sleep(1);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		t.running = false;
	}
	
}
```

1) volatile 引用类型（包括数组）只能保证引用本身的可见性，不能保证内部字段的可见性

2) volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized

3）归根结底，使用的是硬件层面，缓存一致性协议

4）volatile可以保证可见性，但不能替代synchronized保证原子性

### 2）禁止指令重排序

编译器编译代码后，在汇编层面，可能会把代码重新排序

应用：DCL(double check lock)单例模式

```java
public class Test2 {
    private static /*volatile*/ Test2 INSTANCE;
    private Test2(){
    }
    public static Test2 getInstance(){
        if(INSTANCE==null){
            //双重检查
            synchronized(Test2.class){
                if(INSTANCE==null){
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    INSTANCE = new Test2();
                }
            }
        }
        return INSTANCE;
    }
}

```

面试题：

单例模式中的，DCL单例要不要加volatile?

答：要加，因为对象初始化的过程中很有可能发生指令重排，导致半初始化状态的对象出现。这个时候第二个线程过来拿对象，此时，INCSTANCE!=null ，就会得到一个半初始化状态的对象。此情况在超高并发的状态会出现。

相关内容：对象的初始化过程，有可能也会被问到

如何先的禁止指令重排？ 加了内存屏障，读写屏障 loadfence原语指令，storefence愿语指令

# 四、AtomicXXX类

通过cas保证线程安全类 java.util.concurrent.atomic 包下的类

```java
/**
 * 解决同样的问题的更高效的方法，使用AtomXXX类
 * AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的
 * @author mashibing
 */
package com.mashibing.juc.c_018_00_AtomicXXX;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;


public class T01_AtomicInteger {
	/*volatile*/ //int count1 = 0;
	
	AtomicInteger count = new AtomicInteger(0); 

	/*synchronized*/ void m() { 
		for (int i = 0; i < 10000; i++)
			//if count1.get() < 1000
			count.incrementAndGet(); //count1++
	}

	public static void main(String[] args) {
		T01_AtomicInteger t = new T01_AtomicInteger();

		List<Thread> threads = new ArrayList<Thread>();

		for (int i = 0; i < 10; i++) {
			threads.add(new Thread(t::m, "thread-" + i));
		}

		threads.forEach((o) -> o.start());

		threads.forEach((o) -> {
			try {
				o.join();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		});

		System.out.println(t.count);

	}

}
```

AtomicLong 和LongAdder 和synchronize的效率对比代码

```java
package com.mashibing.juc.c_018_00_AtomicXXX;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

public class T02_AtomicVsSyncVsLongAdder {
    static long count2 = 0L;
    static AtomicLong count1 = new AtomicLong(0L);
    static LongAdder count3 = new LongAdder();

    public static void main(String[] args) throws Exception {
        Thread[] threads = new Thread[1000];

        for(int i=0; i<threads.length; i++) {
            threads[i] =
                    new Thread(()-> {
                        for(int k=0; k<100000; k++) count1.incrementAndGet();
                    });
        }

        long start = System.currentTimeMillis();

        for(Thread t : threads ) t.start();

        for (Thread t : threads) t.join();

        long end = System.currentTimeMillis();

        //TimeUnit.SECONDS.sleep(10);

        System.out.println("Atomic: " + count1.get() + " time " + (end-start));
        //-----------------------------------------------------------
        Object lock = new Object();

        for(int i=0; i<threads.length; i++) {
            threads[i] =
                new Thread(new Runnable() {
                    @Override
                    public void run() {

                        for (int k = 0; k < 100000; k++)
                            synchronized (lock) {
                                count2++;
                            }
                    }
                });
        }

        start = System.currentTimeMillis();

        for(Thread t : threads ) t.start();

        for (Thread t : threads) t.join();

        end = System.currentTimeMillis();


        System.out.println("Sync: " + count2 + " time " + (end-start));


        //----------------------------------
        for(int i=0; i<threads.length; i++) {
            threads[i] =
                    new Thread(()-> {
                        for(int k=0; k<100000; k++) count3.increment();
                    });
        }

        start = System.currentTimeMillis();

        for(Thread t : threads ) t.start();

        for (Thread t : threads) t.join();

        end = System.currentTimeMillis();

        //TimeUnit.SECONDS.sleep(10);

        System.out.println("LongAdder: " + count1.longValue() + " time " + (end-start));

    }

    static void microSleep(int m) {
        try {
            TimeUnit.MICROSECONDS.sleep(m);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}
```

效率对比 ： longAdder > atomicLong > sync

为何LongAdder最快？LongAdder用了分段锁 。将大量线程的递增操作分而治之，最后求总和



# 五、CAS(无锁优化，乐观锁，自旋)

1）Compare And Set /Swap

cas(实际值V，期望值E，新值NewVal)

if  V==E  

赋值V = NewVal

否则重试，重新将期望值替换，再进行新值的赋值

cas是cpu愿语支持，中间不能打断

2）ABA问题

加版本号限定

A1.0

B2.0

A3.0

## 9.Unsafe类

其中 compareAndSwap 方法用的就是cas 

Unsafe中有 allocateMemory方法 直接分配内存

Unsafe类 类似于C++中的指针



# 六、各种JUC包的同步锁

## 1.ReentrantLock

### 1）介绍

可重入锁的一种，synchronize 也是一种

```java
/**
 * reentrantlock用于替代synchronized
 * 由于m1锁定this,只有m1执行完毕的时候,m2才能执行
 * 这里是复习synchronized最原始的语义
 * 
 * 使用reentrantlock可以完成同样的功能
 * 需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）
 * 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放
 * @author mashibing
 */
package com.mashibing.juc.c_020;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class T02_ReentrantLock2 {
	Lock lock = new ReentrantLock();

	void m1() {
		try {
			lock.lock(); //synchronized(this)
			for (int i = 0; i < 10; i++) {
				TimeUnit.SECONDS.sleep(1);

				System.out.println(i);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}

	void m2() {
		try {
			lock.lock();
			System.out.println("m2 ...");
		} finally {
			lock.unlock();
		}

	}

	public static void main(String[] args) {
		T02_ReentrantLock2 rl = new T02_ReentrantLock2();
		new Thread(rl::m1).start();
		try {
			TimeUnit.SECONDS.sleep(1);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		new Thread(rl::m2).start();
	}
}
```

### 2）用法

`tryLock(Time)`

使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待。

`lockInterruptibly()`

给当前线程加一个可以被打断的锁。当另一个线程执行t1.interrupt方法的时候可以打断当前的等待。

`new Reentrantlock(true)` 

公平锁，在构造方法中传递参数true代表这是一个公平锁，先来后到的顺序获得锁

### 3）ReentrantLock   与 Synchronize的区别

Sync只有非公平锁，ReentrantLock可以设置公平非公平

Sync没有trylock和lockInterruptibly

## 2.CountDownLatch 

```java
 private static void usingCountDownLatch() {
        Thread[] threads = new Thread[100];
        CountDownLatch latch = new CountDownLatch(threads.length);

        for(int i=0; i<threads.length; i++) {
            threads[i] = new Thread(()->{
                int result = 0;
                for(int j=0; j<10000; j++) result += j;
                latch.countDown();
            });
        }

        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }

        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("end latch");
    }
```

倒数门栓，用来等待线程结束，然后做某事



## 3.CyclicBarrier

循环的栅栏，人满了，栅栏推倒，执行程序

等线程计数到规定值，执行某段程序

```java
public class T07_TestCyclicBarrier {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(20, () -> System.out.println("ÂúÈË"))
        for(int i=0; i<100; i++) {

                new Thread(()->{
                    try {
                        barrier.await();//一定要在线程中加这个await

                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                }).start();
            
        }
    }
}
```

### 1）运用场景

需要等待多个线程的操作都完成再执行某操作

## 4.Phaser

多阶段的栅栏

继承Phaser类实现其中的方法，每个阶段栅栏推到后执行实现方法中的代码

## 5.ReadWriteLock

###  1）介绍

大量的读线程和少量的写线程访问一个资源的时候，可以加读写锁，读线程之间不互斥，但读锁对写锁互斥。

### 2）代码

```java
public class T10_TestReadWriteLock {
    static Lock lock = new ReentrantLock();//这是普通互斥锁
    private static int value;

    static ReadWriteLock readWriteLock = new ReentrantReadWriteLock();//创建读写锁
    static Lock readLock = readWriteLock.readLock();//读锁 也叫共享锁
    static Lock writeLock = readWriteLock.writeLock();//写锁 也叫互斥锁

    public static void read(Lock lock) {
        try {
            lock.lock();
            Thread.sleep(1000);
            System.out.println("read over!");
            //模拟读取操作
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public static void write(Lock lock, int v) {
        try {
            lock.lock();
            Thread.sleep(1000);
            value = v;
            System.out.println("write over!");
            //模拟写操作
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public static void main(String[] args) {
        //Runnable readR = ()-> read(lock);
        Runnable readR = ()-> read(readLock);

        //Runnable writeR = ()->write(lock, new Random().nextInt());
        Runnable writeR = ()->write(writeLock, new Random().nextInt());

        for(int i=0; i<18; i++) new Thread(readR).start();
        for(int i=0; i<2; i++) new Thread(writeR).start();
    }
}
```

## 6.Semaphore （信号灯）

### 1）简介

类似一个信号灯，一个线程调用aquire方法后，得到点亮这个灯，其他的线程就不能执行，可以在构造方法中申请总共几盏灯，就是可以同时执行的线程数。

### 2）作用

限流，类似车道和收费站的关系

### 3）代码

```java
public class T11_TestSemaphore {
    public static void main(String[] args) {
        //Semaphore s = new Semaphore(2);
        Semaphore s = new Semaphore(2, true);//第二个参数，是否公平锁，默认非公平锁
        //允许一个线程同时执行
        //Semaphore s = new Semaphore(1);

        new Thread(()->{
            try {
                s.acquire();

                System.out.println("T1 running...");
                Thread.sleep(200);
                System.out.println("T1 running...");

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                s.release();
            }
        }).start();

        new Thread(()->{
            try {
                s.acquire();

                System.out.println("T2 running...");
                Thread.sleep(200);
                System.out.println("T2 running...");

                s.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

## 7.Exchanger

### 1）使用场景

两个线程之间交换值，可用在点对点交易的业务

![image-20200419123526224](/图片/image-20200419123526224.png)

执行到exchanger.exchage方法的时候，线程会阻塞住，等待另一个线程执行exchanger.exchage方法

### 2）代码

```java
public class T12_TestExchanger {

    static Exchanger<String> exchanger = new Exchanger<>();//创建一个同步容器

    public static void main(String[] args) {
        new Thread(()->{
            String s = "T1";
            try {
                s = exchanger.exchange(s);//在这里阻塞 ，s取得交换后的值
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " " + s);

        }, "t1").start();

        new Thread(()->{
            String s = "T2";
            try {
                s = exchanger.exchange(s);//在这里阻塞，s取得交换后的值
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " " + s);

        }, "t2").start();
    }
}
```

## 8.LockSupport.park()

### 1）简述：

类似于wait、notiffy  但这个能指定某线程的阻塞和恢复，而notify不能。uppark可以先于park执行。

而且wat,notify必须配合synchronize使用.lock.wait.当前线程释放锁，进入等待，lock.notify通知持有这把锁的另一个线程继续执行



### 2）代码

```java
public class T13_TestLockSupport {
    public static void main(String[] args) {
        Thread t = new Thread(()->{
            for (int i = 0; i < 10; i++) {
                System.out.println(i);
                if(i == 5) {
                    LockSupport.park();
                }
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        t.start();

        LockSupport.unpark(t);

        /*try {
            TimeUnit.SECONDS.sleep(8);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("after 8 senconds!");
        LockSupport.unpark(t);*/

    }
}
```

# 七、同步、面试题

## 1.两个线程间通信

实现一个容器，提供两个方法，add，size。写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束

```java
/**
 * 错误的实现方法1：用Volatile保证线程间通信,但这种方法有弊端
 *
 * 给lists添加volatile之后，t2能够接到通知，但是，t2线程的死循环很浪费cpu，如果不用死循环，
 * 而且，如果在if 和 break之间被别的线程打断，得到的结果也不精确，
 * 该怎么做呢？
 *
 *结论：谨慎使用Volvatile
 * @author mashibing
 */
package com.mashibing.juc.c_020_01_Interview;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.TimeUnit;


public class T02_WithVolatile {

	//添加volatile，使t2能够得到通知
	//volatile List lists = new LinkedList();
	volatile List lists = Collections.synchronizedList(new LinkedList<>());

	public void add(Object o) {
		lists.add(o);
	}

	public int size() {
		return lists.size();
	}

	public static void main(String[] args) {

		T02_WithVolatile c = new T02_WithVolatile();
		new Thread(() -> {
			for(int i=0; i<10; i++) {
				c.add(new Object());
				System.out.println("add " + i);
				
				/*try {
					TimeUnit.SECONDS.sleep(1);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}*/
			}
		}, "t1").start();
		
		new Thread(() -> {
			while(true) {
				if(c.size() == 5) {
					break;
				}
			}
			System.out.println("t2 结束");
		}, "t2").start();
	}
}
```

```java
/**
 * 方法2：
 * 这里使用wait和notify做到，wait会释放锁，而notify不会释放锁
 * 需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以
 * 
 * 阅读下面的程序，并分析输出结果
 * 可以读到输出结果并不是size=5时t2退出，而是t1结束时t2才接收到通知而退出
 * 想想这是为什么？
 * 
 * 答：notify之后，t1必须释放锁，t2退出后，也必须notify，通知t1继续执行
 * 整个通信过程比较繁琐
 * @author mashibing
 */
package com.mashibing.juc.c_020_01_Interview;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;


public class T04_NotifyFreeLock {

	//添加volatile，使t2能够得到通知
	volatile List lists = new ArrayList();

	public void add(Object o) {
		lists.add(o);
	}

	public int size() {
		return lists.size();
	}
	
	public static void main(String[] args) {
		T04_NotifyFreeLock c = new T04_NotifyFreeLock();
		
		final Object lock = new Object();
		
		new Thread(() -> {
			synchronized(lock) {
				System.out.println("t2启动");
				if(c.size() != 5) {
					try {
						lock.wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				System.out.println("t2 结束");
				//通知t1继续执行
				lock.notify();
			}
			
		}, "t2").start();
		
		try {
			TimeUnit.SECONDS.sleep(1);
		} catch (InterruptedException e1) {
			e1.printStackTrace();
		}

		new Thread(() -> {
			System.out.println("t1启动");
			synchronized(lock) {
				for(int i=0; i<10; i++) {
					c.add(new Object());
					System.out.println("add " + i);
					
					if(c.size() == 5) {
						lock.notify();
						//释放锁，让t2得以执行
						try {
							lock.wait();
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
					
					try {
						TimeUnit.SECONDS.sleep(1);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
		}, "t1").start();
		
		
	}
}
```

```java

//方法3： park unpark

public class T06_LockSupport {

	// 添加volatile，使t2能够得到通知
	volatile List lists = new ArrayList();

	public void add(Object o) {
		lists.add(o);
	}

	public int size() {
		return lists.size();
	}

	public static void main(String[] args) {
		T06_LockSupport c = new T06_LockSupport();

		CountDownLatch latch = new CountDownLatch(1);

		Thread t2 = new Thread(() -> {
			System.out.println("t2启动");
			LockSupport.park();
			System.out.println("t2 结束");//这里被叫醒后，没有通知t1继续执行后续代码
			LockSupport.unpark(t1);//因此，在这里要叫醒t1继续执行

		}, "t2");

		t2.start();  

		try {
			TimeUnit.SECONDS.sleep(1);
		} catch (InterruptedException e1) {
			e1.printStackTrace();
		}

		new Thread(() -> {
			System.out.println("t1启动");
			for (int i = 0; i < 10; i++) {
				c.add(new Object());
				System.out.println("add " + i);

				if (c.size() == 5) {
					LockSupport.unpark(t2);//这里unpark叫醒t2后，t1还会继续执行，这是个问题
                      LockSupport.park();//因此在这里继续park t1
				}

				/*try {
					TimeUnit.SECONDS.sleep(1);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}*/
			}

		}, "t1").start();

	}
}
```

## 2.生产、消费同步容器（需要背ReentrantLock版本）

```java
/**
 * 面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，
 * 能够支持2个生产者线程以及10个消费者线程的阻塞调用
 * 方法1：
 * 使用wait和notify/notifyAll来实现
 * 有一个问题：这里使用的等待队列是生产者和消费者公用的，因此当notifyAll的时候，被唤醒的不能是你指定的生产者，或者消费者
 * @author mashibing
 */
package com.mashibing.juc.c_021_01_interview;

import java.util.LinkedList;
import java.util.concurrent.TimeUnit;

public class MyContainer1<T> {
	final private LinkedList<T> lists = new LinkedList<>();
	final private int MAX = 10; //最多10个元素
	private int count = 0;
	
	
	public synchronized void put(T t) {
		while(lists.size() == MAX) { //想想为什么用while而不是用if？
			try {
				this.wait(); //答：因为线程被唤醒后需要再次检查容器是否等于最大值
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		
		lists.add(t);
		++count;
		this.notifyAll(); //通知消费者线程进行消费
	}
	
	public synchronized T get() {
		T t = null;
		while(lists.size() == 0) {
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		t = lists.removeFirst();
		count --;
		this.notifyAll(); //通知生产者进行生产
		return t;
	}
	
	public static void main(String[] args) {
		MyContainer1<String> c = new MyContainer1<>();
		//启动消费者线程
		for(int i=0; i<10; i++) {
			new Thread(()->{
				for(int j=0; j<5; j++) System.out.println(c.get());
			}, "c" + i).start();
		}
		
		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		//启动生产者线程
		for(int i=0; i<2; i++) {
			new Thread(()->{
				for(int j=0; j<25; j++) c.put(Thread.currentThread().getName() + " " + j);
			}, "p" + i).start();
		}
	}
}
```

```java
/**
 * 方法2：
 * 使用Lock和Condition来实现
 * 对比两种方式，Condition的方式可以更加精确的指定哪些线程被唤醒
 * 对比wait/notify是用的一个等待队列，而这里用condition是相当于一个condition一个等待队列
 * @author mashibing
 */
package com.mashibing.juc.c_021_01_interview;

import java.util.LinkedList;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class MyContainer2<T> {
	final private LinkedList<T> lists = new LinkedList<>();
	final private int MAX = 10; //最多10个元素
	private int count = 0;
	
	private Lock lock = new ReentrantLock();
	private Condition producer = lock.newCondition();//condition的本质是等待队列
	private Condition consumer = lock.newCondition();
	
	public void put(T t) {
		try {
			lock.lock();
			while(lists.size() == MAX) { 
				producer.await();//让生产者阻塞
			}
			
			lists.add(t);
			++count;
			consumer.signalAll(); //通知消费者线程进行消费
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}
	
	public T get() {
		T t = null;
		try {
			lock.lock();
			while(lists.size() == 0) {
				consumer.await();
			}
			t = lists.removeFirst();
			count --;
			producer.signalAll(); //通知生产者进行生产
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
		return t;
	}
	
	public static void main(String[] args) {
		MyContainer2<String> c = new MyContainer2<>();
		//启动消费者线程
		for(int i=0; i<10; i++) {
			new Thread(()->{
				for(int j=0; j<5; j++) System.out.println(c.get());
			}, "c" + i).start();
		}
		
		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		//启动生产者线程
		for(int i=0; i<2; i++) {
			new Thread(()->{
				for(int j=0; j<25; j++) c.put(Thread.currentThread().getName() + " " + j);
			}, "p" + i).start();
		}
	}
}
```

```java
//方法5：TransferQueue
public class T13_TransferQueue {
    public static void main(String[] args) {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        TransferQueue<Character> queue = new LinkedTransferQueue<Character>();
        new Thread(()->{
            try {
                for (char c : aI) {
                    System.out.print(queue.take());//阻塞取值并输出
                    queue.transfer(c);//然后向queue中传递值
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t1").start();

        new Thread(()->{
            try {
                for (char c : aC) {
                    queue.transfer(c);//先传递值
                    System.out.print(queue.take());//然后取值
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t2").start();
    }
}
```



# 八、AQS（AbstractQuenedSynchronizer）

## 1.如何阅读源码

为啥读源码很难，因为源码是别人的思路，理解别人的思路，需要先达到人家的高度

因此需要两方面基础：1）数据结构  2）设计模式

源码阅读原则：

1）跑不起来不读，因为代码存在多态，需要用debug追踪

2）解决问题就好--》目的性

3）一条线索到底

4）无关细节略过

5）尝试画图UML类图，和方法之间的调用图，可以根据源码直接生成类图

## 2.AQS源码梗概：

Template Method

Callback Function

父类默认实现，子类具体实现

类图：

![image-20200419205508976](/图片/image-20200419205508976.png)

### 1）模板方法模式

​     模式关键要素：1）抽象父类，规定一个执行框架。2）具体子类，不同的子类可有不同的实现。如有需要可添加钩子函数。3）抽象父类中定义的模板方法，即一套固定的算法框架，模板方法必须生命成 **final** ，不能被子类覆写。

​    模式使用场景：1）算法或者操作遵循相似的逻辑 2）重构时，把相同的代码提取到父类 3）重要复杂的算法，核心算法设计为模板方法

​    模式的优点：1）封装性好 2）复用性好 3）屏蔽细节 4）便于维护

### 2）源码分析

AQS类中有一个Node内部类，是个双向链表，作为一个等待队列

AQS中有一个Volatile修饰的state值，记录ReentrantLock的锁重入次数。通过CAS修改该值，修改成功，则占有锁，修改失败进入等待队列

关于AQS为何效率高：Node链表置换尾巴也用到了CAS操作，避免了等待队列锁整条链表，只对最后一个节点做CAS置换操作，所以效率高

关于addWaiter方法中的VarHandle （jdk9之后才有）:

一个可以进行CAS操作的句柄，可以替换其他引用进行CAS操作，原子性的线程安全的操作

普通属性也可以进行原子性操作，且比反射更快，直接操纵二进制码

```java
package com.mashibing.juc.c_021_03_VarHandle;

import java.lang.invoke.MethodHandles;
import java.lang.invoke.VarHandle;

public class T01_HelloVarHandle {

    int x = 8;

    private static VarHandle handle;

    static {
        try {
            handle = MethodHandles.lookup().findVarHandle(T01_HelloVarHandle.class, "x", int.class);
            //相当于用handle指向了x所指向的变量，此时同时两个引用指向同一个变量
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        T01_HelloVarHandle t = new T01_HelloVarHandle();

        //plain read / write
        System.out.println((int)handle.get(t));
        handle.set(t,9);
        System.out.println(t.x);

        handle.compareAndSet(t, 9, 10);//可以进行原子性的操作
        System.out.println(t.x);

        handle.getAndAdd(t, 10);
        System.out.println(t.x);

    }
}
```



# 九、引用分类-强软弱虚

什么是引用：

## 1.强引用

通常new 一个对象 的引用就是强引用，当对象的引用置为空的时候，gc将会回收这个对象

实现对象的 finalize方法可以观察对象被回收的时机

## 2.软引用

当一个对象被软引用指向时，只有内存不够用时，该对象才会被回收

```java
/**
 * 软引用
 * 软引用是用来描述一些还有用但并非必须的对象。
 * 对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收。
 * 如果这次回收还没有足够的内存，才会抛出内存溢出异常。
 * -Xmx20M
 */
package com.mashibing.juc.c_022_RefTypeAndThreadLocal;

import java.lang.ref.SoftReference;

public class T02_SoftReference {
    public static void main(String[] args) {
        SoftReference<byte[]> m = new SoftReference<>(new byte[1024*1024*10]);//先申请10M空间的数组
        //m = null;
        System.out.println(m.get());
        System.gc();
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(m.get());

        //再分配一个数组，heap将装不下，这时候系统会垃圾回收，先回收一次，如果不够，会把软引用干掉
        byte[] b = new byte[1024*1024*15];
        System.out.println(m.get());
    }
}

//软引用非常适合缓存使用。比如大图片，放在缓存加载，如果内存不够用，则让gc回收掉
```

## 3.弱引用

### 1）ThreadLocal

1.概括：每个线程维护自己的一个Map，k是ThreadLocal，V是值。ThreadLocal是使用空间换时间，synchronized是使用时间换空间。说弱引用之前需要先说明白ThreadLocal。

2.用途：声明式事务，例如Mybatis获得Connection的时候是把每个线程的Connection放到ThreadLocal中保证同一个Connection

作业：weakHashMap, ReentrantLock.unlock源码

```java
/**
 * 弱引用遭到gc就会回收
 *用途：一般用在容器中，如果一个对象被弱引用指向，且同时被强引用指向，则强引用消失时，对象被回收
 */
package com.mashibing.juc.c_022_RefTypeAndThreadLocal;

import java.lang.ref.WeakReference;

public class T03_WeakReference {
    public static void main(String[] args) {
        WeakReference<M> m = new WeakReference<>(new M());

        System.out.println(m.get());
        System.gc();
        System.out.println(m.get());//m所指向的对象遇到gc就会被回收


        ThreadLocal<M> tl = new ThreadLocal<>();
        tl.set(new M());//相当于tl指向ThreadLocal对象，对象中又引用了一个M对象
        tl.remove();//用完必须remove

    }
}
```

弱引用在ThreadLocal中的运用

![image-20200420172744687](/图片/image-20200420172744687.png)

tl 指向ThreadLocal对象，这是一个强引用，但ThreadLocalMap实际上是一个实现了WeakRefrence类的Entry,切这个Entry的k是TreadLocal类型，因此这个k是以弱引用指向了ThreadLocal对象。

如果Map中的key是以强应用指向ThreadLocal对象，则当方法结束tl引用不再指向ThreadLocal时，ThreadLocal对象依然不会被回收，因此会导致内存泄漏（MemoryLeak）

但是仍然有问题,此时虽然Map中的k指向的对象为Null（被回收）,但ThreadLocal中的Map是永远存在的，Map的v是访问不到，因此依然会导致内存泄漏，所以ThreadLocal用完需要执行remove方法。

## 4.虚引用

管理堆外内存：

当一个对象使用的是堆外内存，你无法直接控制，但可以使用虚引用，如果监控队列中检测到有对象被回收时，可以使用操作去清理堆外内存

```java
/**
 *     一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，
 *     也无法通过虚引用来获取一个对象的实例。
 *     为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
 *     虚引用和弱引用对关联对象的回收都不会产生影响，如果只有虚引用活着弱引用关联着对象，
 *     那么这个对象就会被回收。它们的不同之处在于弱引用的get方法，虚引用的get方法始终返回null,
 *     弱引用可以使用ReferenceQueue,虚引用必须配合ReferenceQueue使用。
 *
 *     jdk中直接内存的回收就用到虚引用，由于jvm自动内存管理的范围是堆内存，
 *     而直接内存是在堆内存之外（其实是内存映射文件，自行去理解虚拟内存空间的相关概念），
 *     所以直接内存的分配和回收都是有Unsafe类去操作，java在申请一块直接内存之后，
 *     会在堆内存分配一个对象保存这个堆外内存的引用，
 *     这个对象被垃圾收集器管理，一旦这个对象被回收，
 *     相应的用户线程会收到通知并对直接内存进行清理工作。
 *
 *     事实上，虚引用有一个很重要的用途就是用来做堆外内存的释放，
 *     DirectByteBuffer就是通过虚引用来实现堆外内存的释放的。
 *
 */


package com.mashibing.juc.c_022_RefTypeAndThreadLocal;

import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.util.LinkedList;
import java.util.List;

public class T04_PhantomReference {
    private static final List<Object> LIST = new LinkedList<>();
    private static final ReferenceQueue<M> QUEUE = new ReferenceQueue<>();//创建一个引用队列



    public static void main(String[] args) {


        PhantomReference<M> phantomReference = new PhantomReference<>(new M(), QUEUE);//一定需要两个参数


        new Thread(() -> {
            while (true) {
                LIST.add(new byte[1024 * 1024]);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    Thread.currentThread().interrupt();
                }
                System.out.println(phantomReference.get());
            }
        }).start();

        new Thread(() -> {
            while (true) {
                Reference<? extends M> poll = QUEUE.poll();
                if (poll != null) {
                    System.out.println("--- 虚引用对象被jvm回收了 ---- " + poll);
                }
            }
        }).start();

        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}
```

# 十、容器

<img src="/图片/image-20200421103035689.png" alt="image-20200421103035689" style="zoom:80%;" />

## 1.从HashTable到ConcurrentHashMap

最早的时候，容器只有两种，Vector和HashTabel。在jdk1的时候默认所有的方法都是加锁的。现在基本不用

Collections.synchronizedMap(new HashMap());  这种方法是使用集合工具类中的枷锁map包装hashMap，与hashTable类似，效率也类似。

HashTable和Collections.synchronizedMap(new HashMap()) 都是线程安全的map但读效率极低。

ConcurrentHashMap写效率虽然略低于HashTable，但读效率极高，它也是线程安全的

HashMap是线程不安全的，多线程进行写操作会发生很多报错和bug

## 2.从Vector到Queue

Vector是早期的线程安全的集合。其内部的方法大多是加了synchronize的。下面程序演示如何从ArrayList-->Vector-->ConcurrentLinkedQueue

```java
/**
 * 有N张火车票，每张票都有一个编号
 * 同时有10个窗口对外售票
 * 请写一个模拟程序
 *
 * 分析下面的程序可能会产生哪些问题？
 * 重复销售？超量销售？
 * @author 马士兵
 */
public class TicketSeller1 {
	static List<String> tickets = new ArrayList<>();
	static {
		for(int i=0; i<10000; i++) tickets.add("票编号：" + i);
	}
		
	public static void main(String[] args) {
		for(int i=0; i<10; i++) {
			new Thread(()->{
				while(tickets.size() > 0) {
					System.out.println("销售了--" + tickets.remove(0));//当size等于0时会有多个线程继续remove,导致拿到空值
				}
			}).start();
		}
	}
    //答：由于ArrayList是线程不安全的，所以会出现超量销售
}
```

```java
//思考下面代码有什么问题，虽然使用了Vector
public class TicketSeller2 {
	static Vector<String> tickets = new Vector<>();
	static {
		for(int i=0; i<1000; i++) tickets.add("票 编号：" + i);
	}
	
	public static void main(String[] args) {
		
		for(int i=0; i<10; i++) {
			new Thread(()->{
				while(tickets.size() > 0) {//这里size是原子操作
					
					try {
						TimeUnit.MILLISECONDS.sleep(10);//多个线程会执行到这里面来，因此下面的remove会有多个线程在size=0的时候继续remove
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					
					System.out.println("销售了--" + tickets.remove(0));//这里remove也是原子操作
				}
			}).start();
            //答：两个原子性的操作合在一起就是非原子性的了
		}
	}
}
```

```java
/* 就算操作A和B都是同步的，但A和B组成的复合操作也未必是同步的，仍然需要自己进行同步
 * 就像这个程序，判断size和进行remove必须是一整个的原子操作
 * 
 * @author 马士兵
 */
package com.mashibing.juc.c_024_FromVectorToQueue;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.TimeUnit;

public class TicketSeller3 {
	static List<String> tickets = new LinkedList<>();
	static {
		for(int i=0; i<1000; i++) tickets.add("票 编号：" + i);
	}
	
	public static void main(String[] args) {
		
		for(int i=0; i<10; i++) {
			new Thread(()->{
				while(true) {
					synchronized(tickets) {//这里加Sinchronize保证整体是原子操作
						if(tickets.size() <= 0) break;
						
						try {
							TimeUnit.MILLISECONDS.sleep(10);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						
						System.out.println("销售了--" + tickets.remove(0));
					}
				}
			}).start();
		}
	}
}
```

```java
/**
 * 使用ConcurrentQueue提高并发性
 * 
 * @author 马士兵
 */
package com.mashibing.juc.c_024_FromVectorToQueue;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class TicketSeller4 {
	static Queue<String> tickets = new ConcurrentLinkedQueue<>();//使用并发队列
	
	
	static {
		for(int i=0; i<1000; i++) tickets.add("票 编号：" + i);
	}
	
	public static void main(String[] args) {
		
		for(int i=0; i<10; i++) {
			new Thread(()->{
				while(true) {
					String s = tickets.poll();//调用其中的poll方法取出头部的值
					if(s == null) break;
					else System.out.println("销售了--" + s);
				}
			}).start();
		}
	}
}
```

## 3.ConcurrentHashMap

​	HashTable, HashMap,ConcurrentHashMap 对比put值的时间测试

​    ConcurrentSkpListMap  高并发且有序，底层是实现了跳表的结构，每层链表上面用关键节点抽出一层链表

## 4.CopyOnWriteArrayList 

​	写时复制的list，需要往数组添加数据时，把数组复制一份并扩容，然后添加数据，再把原数组的引用替换成新的数组

​	使用CopyOnWriteArrayList  读时，无锁，读的是原数组，写时加锁。

​	因此它比Vector高

​	对比Collections.synchronizedList( new ArrayList() ); 读写都加锁，效率低

## 5.BlockingQueue

### 	0) Queue 接口中的方法

​		add 添加值 满了会抛异常

   	 offer 向队列中添加值，加不进去返回false ; peek 从队列中取值，但不会remove值

​		poll 取值并且remove掉值

### 	1) LinkedBlockingQueue

​	 用链表实现的BlockingQueue。无界队列，没有长度限制

​	 put ,take 方法 阻塞的方法，天然实现生产者消费者模型  ，使用了ReentrantLock. newCondition。实现两个同步队列，生产者一个等待队列，消费者一个等待队列，调用condition.await阻塞

###    2）ArrayBlokingQueue 

​	有界的队列，满了就会等待，程序就会阻塞，也可以设置阻塞时间

###  3) 	PriorityQueue  

​	会自动排序的queue,内部实现了一个二叉树

### 4）DelayQueue

​	 按时间排序的queue 其基础是PriorityQueue

### 5) 	SynchronousQueue

​	容量为0的阻塞交换队列，用来直接传递数据到另一个线程，仅当有线程take的时候才能向其中put，相当于手递手传递一个数据

### 6）ThransferQueue

​	 多人对多人的手递手传递，线程Put值之后会被阻塞，直等到有另一个线程take后，它才能继续执行

下面是它的实现类LinkedTransferQueue的执行逻辑，它更像是SynchronousQueue和LinkedBlockingQueue的合体

<img src="/图片/1200" alt="img" style="zoom:50%;" />

LinkedTransferQueue的transfer方法类似SynchronousQueue的put方法，put值并挂起线程，直到等到有另一个线程take值，挂起的线程才继续执行

# 11、线程池

## 1. 1A2B轮换输出面试题

题目：要求用两个线程交替顺序打印A1B2C3....Z26

```java
//方法1：LockSupport.park/unpark
//Locksupport park 当前线程阻塞（停止）
//unpark(Thread t)
public class T02_00_LockSupport {
    static Thread t1 = null, t2 = null;
    public static void main(String[] args) throws Exception {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        t1 = new Thread(() -> {
                for(char c : aI) {
                    System.out.print(c);
                    LockSupport.unpark(t2); //叫醒T2
                    LockSupport.park(); //T1阻塞
                }

        }, "t1");

        t2 = new Thread(() -> {
            for(char c : aC) {
                LockSupport.park(); //t2阻塞
                System.out.print(c);
                LockSupport.unpark(t1); //叫醒t1
            }
        }, "t2");
        t1.start();
        t2.start();
    }
}
```

```java
//方法2：使用自旋的方式CAS
public class T03_00_cas {
    enum ReadyToRun {T1, T2} //使用枚举
    static volatile ReadyToRun r = ReadyToRun.T1; //思考为什么必须volatile,线程间同步

    public static void main(String[] args) {

        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        new Thread(() -> {
            for (char c : aI) {
                while (r != ReadyToRun.T1) {}//因为是初始值是T1所以上来不会自旋
                System.out.print(c);
                r = ReadyToRun.T2;
            }

        }, "t1").start();

        new Thread(() -> {

            for (char c : aC) {
                while (r != ReadyToRun.T2) {}//如果不是T2则自旋等待
                System.out.print(c);
                r = ReadyToRun.T1;
            }
        }, "t2").start();
    }
}
```

```java
//方法3：BlockingQueue.take/put
public class T04_00_BlockingQueue {
    static BlockingQueue<String> q1 = new ArrayBlockingQueue(1);//这里一定要使用两个BlockingQueue
    static BlockingQueue<String> q2 = new ArrayBlockingQueue(1);

    public static void main(String[] args) throws Exception {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        new Thread(() -> {
            for(char c : aI) {
                System.out.print(c);//先输出
                q1.put("ok");//输出完向q1设值
                q2.take();//然后去t2拿，此时t2没有，进入阻塞
            }

        }, "t1").start();

        new Thread(() -> {
            for(char c : aC) {
                q1.take();//先拿值，因为开始没有所以先阻塞
                System.out.print(c);//当q1有值后输出
                q2.put("ok");//向q2设值
            }
        }, "t2").start();
    }
}
```

```java
//方法4：wait/notify
public class T07_00_sync_wait_notify {
    private static volatile boolean t2Started = false;//设置一个标记，保证t2先输出值
    public static void main(String[] args) {
        final Object o = new Object();
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        new Thread(()->{
            synchronized (o) {
                while(!t2Started) {//如果t2先输出了，这里才不会执行等待
                    o.wait();
                }
                for(char c : aI) {
                    System.out.print(c);
                        o.notify();
                        o.wait();
                }

                o.notify();//必须，否则循环结束后，线程仍然会等待，挂起
            }
        }, "t1").start();

        new Thread(()->{

            synchronized (o) {
                for(char c : aC) {
                    System.out.print(c);
                    t2Started = true;//t2执行后置为true
                    o.notify();
                    o.wait();
                }
                o.notify();
            }
        }, "t2").start();
    }
}

```

```java
//方法6：TransferQueue
public class T13_TransferQueue {
    public static void main(String[] args) {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        TransferQueue<Character> queue = new LinkedTransferQueue<Character>();
        new Thread(()->{
            try {
                for (char c : aI) {
                    System.out.print(queue.take());//先阻塞取值
                    queue.transfer(c);//待输出值后，传值
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t1").start();

        new Thread(()->{
            try {
                for (char c : aC) {
                    queue.transfer(c);//先传值
                    System.out.print(queue.take());//再等待另一个线程传值后输出
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t2").start();
    }
}
```

## 2.相关接口、类、方法

Excutor: 将线程的定义和运行分开，实现Excutor可以实现不同的执行方式

ExcutorService:

完善了任务执行器的生命周期，比如结束，判断结束，提交任务

Callable

在1.5之后增加了Callable接口，有返回值的Runnable, 返回值要封装到Future中，Future中有用来取返回值 的方法

Future

FutureTask   既可以直接用线程执行，也可以用线程池执行，还有返回结果，比较全能

CompletableFuture

一个高级管理类，可以方便管理多个异步线程，并且等待所有线程完成，然后收集结果

## 3.两类线程池

1.ThreadPoolExecutor

2.ForkJoinPool 

​	分解汇总的任务

## 4.自定义线程池ThreadPoolExecutor

1）完整的线程池中包含什么：

1线程的集合   2任务的集合

2）定义线程池的7个参数：

corePoolSize 核心线程数

maximumPoolSize 最大线程数

keepAliveTime  核心线程外的线程的最大存活时间

timeUnit  存活时间的单位

workQueue 任务队列，存放被提交但还没执行的Task

threadFactory  实现一个创建线程的类

handler  拒绝策略

3）自定义线程池的运转流程

a.当来第一个任务时，启动核心线程，任务结束即使超过保活时间也不会回收核心线程

b.当核心线程都被占用，再来任务时，将任务加入workQueue任务队列

c.当任务队列满，起动新线程执行任务

d.当线程池中线程数达到最大值，而任务队列也满了，执行拒绝策略

4）jdk提供的默认4种拒绝策略

AbortPolicy：抛异常	DiscardPolicy：扔掉，不抛异常	DiscardOldestPolicy：扔掉排队时间最久的	CallerRunsPolicy:调用者处理任务

5）实际情况中的拒绝策略

实战	以上四种默认都不会用，一般被拒绝的都会存起来，以备后续执行

```java
//----实现一个自定义线程池----
public class T05_00_HelloThreadPool {
    static class Task implements Runnable {
        private int i;//一个任务需要的编号

        public Task(int i) {
            this.i = i;
        }

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " Task " + i);
            try {
                System.in.read();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        @Override
        public String toString() {
            return "Task{" +
                    "i=" + i +
                    '}';
        }
    }

    public static void main(String[] args) {
        ThreadPoolExecutor tpe = new ThreadPoolExecutor(2, 4,//自定义线程池
                60, TimeUnit.SECONDS,
                new ArrayBlockingQueue<Runnable>(4),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy());

        for (int i = 0; i < 8; i++) {
            tpe.execute(new Task(i));
        }

        System.out.println(tpe.getQueue());
        tpe.execute(new Task(100));
        System.out.println(tpe.getQueue());
        tpe.shutdown();
    }
}
```

```java
//实现一个自定义拒绝策略
public class T14_MyRejectedHandler {
    public static void main(String[] args) {
        ExecutorService service = new ThreadPoolExecutor(4, 4,
                0, TimeUnit.SECONDS, new ArrayBlockingQueue<>(6),
                Executors.defaultThreadFactory(),
                new MyHandler());
    }

    static class MyHandler implements RejectedExecutionHandler {

        @Override
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
            //log("r rejected")      //在这里实现自定义的拒绝后的操作,把任务保存或者存到kafka等等
            //save r kafka mysql redis
            //try 3 times
            if(executor.getQueue().size() < 10000) {
                //try put again();   //如果等待队列有位子了，再把任务放到等待队列中
            }
        }
    }
}
```



## 5.ThreadPoolExecutor源码

todo



## 6.JDK默认线程池

Executors 线程池工具类-线程池工厂

### 1) SingleThreadPool  

 一个线程的线程池，保证任务顺序执行

![image-20200424163616958](/图片/image-20200424163616958.png)

实质上还是一个自定义的线程池，只有一个核心线程，最大线程为1，使用LinkedBlockingQueue来进行任务存储	

为什么要有单线程的线程池？提供任务队列，生命周期管理

### 2) cachedThreadPool 

![image-20200424164632207](/图片/image-20200424164632207.png)

核心线程数为0，最大线程数为Integer.MAX_VALUE，保活时间60秒，使用SynchronousQueue储存任务，也就是说当有一个任务被提交时，必须有新线程来承接这个任务，否则提交线程就一直阻塞。

### 3) FixedThreadPool

![image-20200424165517983](/图片/image-20200424165517983.png)

指定核心线程数，没有保活时间因为，都是核心线程创建了就不会消失，使用LinkedBlockingQueue存储任务。

问：何时用Cached和Fixed？关键在于有多少线程数，任务数量忽高忽低用cached，任务数量稳定用fixed

### 4) ScheduleThreadPool  

![image-20200424171258632](/图片/image-20200424171258632.png)

super调用其父类ThreadPoolExecutor构造,自定的核心线程数，其他都是默认，唯独使用DelayWorkQueue

```java
public static void main(String[] args) {
		ScheduledExecutorService service = Executors.newScheduledThreadPool(4);
		service.scheduleAtFixedRate(()->{//以固定频率执行任务
			try {
				TimeUnit.MILLISECONDS.sleep(new Random().nextInt(1000));
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(Thread.currentThread().getName());
		}, 0, 500, TimeUnit.MILLISECONDS);
		
	}
```

定时任务线程池

​	定义了DelayedBlokingQueue,用的不多，复杂的用定时任务框架quotz,简单的用timmerTask

突然想起的面试题：

​	十亿次闹钟通知任务，如何优化

​	分而治之，使用集群，同步这些任务。每台服务器再使用队列存储，用线程池去消费这些队列中的任务

并发和并行

​	concurrent  vs  parallel    并发指任务提交，并行指任务执行，并行是并发的子集

拒绝策略的自定义

​	实现RejectedExecutionHandler接口

## 7.ForkJoinPool:

### 1) 介绍及用法

ForkJoinPool是ExecutorSerice的一个补充，而不是替代品，适用于“分而治之”的场景，可以递归计算的算法

如何创建一个ForkJoin类型的任务：

可以继承ForkJoinTask，但比较原始

或者继承RecursiveAction，实现递归算法,没有返回值；有返回值的使用RecursiveTask。

```java
public class T12_ForkJoinPool {
	static int[] nums = new int[1000000];
	static final int MAX_NUM = 50000;//递归达到这个数量级就可以计算了
	static Random r = new Random();
	
	static {
		for(int i=0; i<nums.length; i++) {
			nums[i] = r.nextInt(100);
		}
		System.out.println("---" + Arrays.stream(nums).sum()); //stream api
	}
	
	//不带返回值的ForkJoinTask
	static class AddTask extends RecursiveAction {
		int start, end;//起始值，结束值
		AddTask(int s, int e) {
			start = s;
			end = e;
		}

		@Override
		protected void compute() {//重写compute方法

			if(end-start <= MAX_NUM) {//达到目标值，开始执行计算
				long sum = 0L;
				for(int i=start; i<end; i++) sum += nums[i];
				System.out.println("from:" + start + " to:" + end + " = " + sum);//打印输出
			} else {
				int middle = start + (end-start)/2;//没达到，劈一半，递归
				AddTask subTask1 = new AddTask(start, middle);
				AddTask subTask2 = new AddTask(middle, end);
				subTask1.fork();
				subTask2.fork();
			}
		}
	}

	//带返回值的ForkJoinTask
	static class AddTaskRet extends RecursiveTask<Long> {
		private static final long serialVersionUID = 1L;
		int start, end;
		AddTaskRet(int s, int e) {
			start = s;
			end = e;
		}

		@Override
		protected Long compute() {
			if(end-start <= MAX_NUM) {
				long sum = 0L;
				for(int i=start; i<end; i++) sum += nums[i];
				return sum;//将结果返回
			} 
			int middle = start + (end-start)/2;
			AddTaskRet subTask1 = new AddTaskRet(start, middle);
			AddTaskRet subTask2 = new AddTaskRet(middle, end);
			subTask1.fork();
			subTask2.fork();
			
			return subTask1.join() + subTask2.join();//最终将结果汇总，并返回
		}
	}
	
	public static void main(String[] args) throws IOException {
		/*ForkJoinPool fjp = new ForkJoinPool();
		AddTask task = new AddTask(0, nums.length);
		fjp.execute(task);*/

		T12_ForkJoinPool temp = new T12_ForkJoinPool();
		ForkJoinPool fjp = new ForkJoinPool();
		AddTaskRet task = new AddTaskRet(0, nums.length);
		fjp.execute(task);
		long result = task.join();//获取结果
		System.out.println(result);
		//System.in.read();
	}
}
```

### 2) WorkSteallingPool

通过ForkJoinPool实现的自定义线程池

对比：ThreadPoolExecutor是多个线程共享一个任务队列，而WorkStealingPool是每个线程对应自己的任务队列

### 3) ParallelStreamAPI

并行流，底层实现也是ForkJoinPool

```java
public class T13_ParallelStreamAPI {
	public static void main(String[] args) {
		List<Integer> nums = new ArrayList<>();
		Random r = new Random();
		for(int i=0; i<10000; i++) nums.add(1000000 + r.nextInt(1000000));
		
		//System.out.println(nums);
		
		long start = System.currentTimeMillis();
		nums.forEach(v->isPrime(v));//使用forEach方法迭代计算每个元素
		long end = System.currentTimeMillis();
		System.out.println(end - start);
		
		//并行stream api
		start = System.currentTimeMillis();
		nums.parallelStream().forEach(T13_ParallelStreamAPI::isPrime);//如果不需要同步，交给并行流处理
		end = System.currentTimeMillis();
		
		System.out.println(end - start);
	}
	
	static boolean isPrime(int num) {
		for(int i=2; i<=num/2; i++) {
			if(num % i == 0) return false;
		}
		return true;
	}
}
```



# 12.JMH

jmh是 Java Microbenchmark Harness 的缩写 ,java微基准测试套件

1.官网：http://openjdk.java.net/projects/code-tools/jmh/

2.依赖：

```xml
 <dependencies>
        <!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core -->
        <dependency>
            <groupId>org.openjdk.jmh</groupId>
            <artifactId>jmh-core</artifactId>
            <version>1.21</version>
        </dependency>

        <!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-generator-annprocess -->
        <dependency>
            <groupId>org.openjdk.jmh</groupId>
            <artifactId>jmh-generator-annprocess</artifactId>
            <version>1.21</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
```

3.idea安装JMH插件  JMH pligin v1.0.3

4.有序用到注解，需要打开程序注解配置

5.定义需要测试类

6.将测试类写在测试test包下

```java
public class PSTest {
    @Benchmark  //执行基准测试注解
    @Warmup(iterations =1,time =3) //预热次数
    @Fork(5) //测试启动的线程数
    @BenchmarkMode(Mode.Throughput) //模式：吞吐量测试
    @Measurement(iterations=1, time=3) //执行次数
    public void testForEach() {
        PS.foreach();
    }
}
```

7.可能会遇到的报错

```java
ERROR: org.openjdk.jmh.runner.RunnerException: ERROR: Exception while trying to acquire the JMH lock (C:\WINDOWS\/jmh.lock): C:\WINDOWS\jmh.lock (拒绝访问。), exiting. Use -Djmh.ignoreLock=true to forcefully continue.
	at org.openjdk.jmh.runner.Runner.run(Runner.java:216)
	at org.openjdk.jmh.Main.main(Main.java:71)
```

这个错误是因为JMH运行需要访问系统的TMP目录，解决办法是：

打开RunConfiguration -> Environment Variables -> include system environment viables

# 13.Disruptor

单机性能最高的消息队列，所有东西性能有限，把性能发挥到极致

## 1.文档

> 主页：http://lmax-exchange.github.io/disruptor/
>
> 源码：https://github.com/LMAX-Exchange/disruptor
>
> GettingStarted: https://github.com/LMAX-Exchange/disruptor/wiki/Getting-Started
>
> api: http://lmax-exchange.github.io/disruptor/docs/index.html
>
> maven: https://mvnrepository.com/artifact/com.lmax/disruptor

2.环形队列 **RingBuffer** 是 **disrupter** 的核心

​		采用数组实现，使用一个序号指向下一个可用的元素，新元素直接覆盖旧元素，降低GC频率提高效率。实现了基于事件的生产者消费者模式（观察者模式）

​		对比ConcurrentLinkedQueue，用数组实现的速度更快

​		如何计算当前应该在哪个位置赋值：采用位与运算

## 2.使用

### 	1）开发步骤

 		定义Event  - 队列中需要处理的元素

 		定义Event工厂，用于填充队列

​		 定义EventHandler（消费者），处理容器中的元素

​		事件发布模板：

```java
long sequence = ringBuffer.next();  // 找到下一个序号
try {
    LongEvent event = ringBuffer.get(sequence); // 获取元素
    // for the sequence
    event.set(8888L);  // 初始化元素
} finally {
    ringBuffer.publish(sequence); //发布这个事件，等待消费者消费
}
```

### 	2）代码样例

```java
public class Main03
{
    public static void main(String[] args) throws Exception
    {
        // Specify the size of the ring buffer, must be power of 2.
        int bufferSize = 1024;
        // Construct the Disruptor
        Disruptor<LongEvent> disruptor = new Disruptor<>(LongEvent::new, bufferSize, DaemonThreadFactory.INSTANCE);

        // Connect the handler
        disruptor.handleEventsWith((event, sequence, endOfBatch) -> System.out.println("Event: " + event));

        // Start the Disruptor, starts all threads running
        disruptor.start();

        // Get the ring buffer from the Disruptor to be used for publishing.
        RingBuffer<LongEvent> ringBuffer = disruptor.getRingBuffer();
        ringBuffer.publishEvent((event, sequence) -> event.set(10000L)); //这里使用了Lamda表达式
        System.in.read();
    }
}
```

### 3）ProducerType生产者线程模式

ProducerType有两种模式 Producer.MULTI和Producer.SINGLE

默认是MULTI，表示在多线程模式下产生sequence

如果确认是单线程生产者，那么可以指定SINGLE，效率会提升

如果是多个生产者（多线程），但模式指定为SINGLE，会出什么问题呢？答：线程安全问题

### 4）等待策略

如果生产者生产的速度大于消费者消费的速度，则需要等待策略

1，(常用）BlockingWaitStrategy：通过线程阻塞的方式，等待生产者唤醒，被唤醒后，再循环检查依赖的sequence是否已经消费。

2，BusySpinWaitStrategy：线程一直自旋等待，可能比较耗cpu

3，LiteBlockingWaitStrategy：线程阻塞等待生产者唤醒，与BlockingWaitStrategy相比，区别在signalNeeded.getAndSet,如果两个线程同时访问一个访问waitfor,一个访问signalAll时，可以减少lock加锁次数.

4，LiteTimeoutBlockingWaitStrategy：与LiteBlockingWaitStrategy相比，设置了阻塞时间，超过时间后抛异常。

5，PhasedBackoffWaitStrategy：根据时间参数和传入的等待策略来决定使用哪种等待策略

6，TimeoutBlockingWaitStrategy：相对于BlockingWaitStrategy来说，设置了等待时间，超过后抛异常

7，（常用）YieldingWaitStrategy：尝试100次，然后Thread.yield()让出cpu

8,（常用）SleepingWaitStrategy : sleep

### 5） 消费者异常处理

默认：disruptor.setDefaultExceptionHandler()

覆盖：disruptor.handleExceptionFor().with()